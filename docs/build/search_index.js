var documenterSearchIndex = {"docs":
[{"location":"invariants/#Invariants","page":"Invariants","title":"Invariants","text":"","category":"section"},{"location":"invariants/","page":"Invariants","title":"Invariants","text":"The Invariants module provides functions to compute invariants for a given graph. These invariants can categorized into these general categories:","category":"page"},{"location":"invariants/","page":"Invariants","title":"Invariants","text":"Chromatic Colorings\nCliques\nDomination\nIndependence\nMatching\nZero Forcing","category":"page"},{"location":"invariants/","page":"Invariants","title":"Invariants","text":"Methods use several optimization approaches including integer programming which is handled through JuMP and uses the default optimizer HiGHS.","category":"page"},{"location":"invariants/","page":"Invariants","title":"Invariants","text":"Modules = [GraphProperties.Invariants]","category":"page"},{"location":"invariants/#GraphProperties.Invariants","page":"Invariants","title":"GraphProperties.Invariants","text":"module Invariants\n\nThe Invariants module provides functionalities for computing various graph invariants and optimal sets, such as cliques, colorings, dominations, and matchings. It includes advanced features for degree sequence invariants and graphical operations based on the rules defined within the module.\n\nExported Types\n\nAbstractOptimalNodeSet: Represents sets of nodes that meet an optimality criterion.\nAbstractOptimalEdgeSet: Represents sets of edges that meet an optimality criterion.\nAbstractOptimalNodeColoring: Represents an optimal coloring of nodes in a graph.\nAbstractOptimalEdgeColoring: Represents an optimal coloring of edges in a graph.\nAbstractCardinality: Represents the cardinality of a set.\nAbstractOptimalCardinality: Represents the cardinality of an optimal set.\nAbstractDegreeSequenceInvariant: Represents an invariant of a graph's degree sequence.\n\nExported Functions\n\ncompute: Computes the optimal set or invariant of a graph.\n\nUsage\n\nThe module allows for the computation of complex graph invariants and operations through high-level functions and types. The types are used to represent the results of these computations, while the functions are used to perform them.\n\nExamples\n\njulia> using GraphProperties.Invariants: compute, MaximumIndependentSet\n\njulia> α = compute(MaximumIndependentSet, my_graph)\n\n\n\n\n\n","category":"module"},{"location":"invariants/#GraphProperties.Invariants.AbstractCardinality","page":"Invariants","title":"GraphProperties.Invariants.AbstractCardinality","text":"AbstractCardinality\n\nRepresents the cardinality of a set.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractDegreeSequenceInvariant","page":"Invariants","title":"GraphProperties.Invariants.AbstractDegreeSequenceInvariant","text":"AbstractDegreeSequenceInvariant\n\nRepresents an invariant of a graph's degree sequence.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractOptimalCardinality","page":"Invariants","title":"GraphProperties.Invariants.AbstractOptimalCardinality","text":"AbstractOptimalCardinality\n\nRepresents the cardinality of an optimal set.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractOptimalEdgeColoring","page":"Invariants","title":"GraphProperties.Invariants.AbstractOptimalEdgeColoring","text":"AbstractOptimalEdgeColoring\n\nRepresents an optimal coloring of edges in a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractOptimalEdgeSet","page":"Invariants","title":"GraphProperties.Invariants.AbstractOptimalEdgeSet","text":"AbstractOptimalEdgeSet\n\nRepresents a set of edges that meet an optimality criterion.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractOptimalNodeColoring","page":"Invariants","title":"GraphProperties.Invariants.AbstractOptimalNodeColoring","text":"AbstractOptimalNodeColoring\n\nRepresents an optimal coloring of nodes in a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AbstractOptimalNodeSet","page":"Invariants","title":"GraphProperties.Invariants.AbstractOptimalNodeSet","text":"AbstractOptimalNodeSet\n\nRepresents a set of nodes that meet an optimality criterion.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AnnihilationNumber","page":"Invariants","title":"GraphProperties.Invariants.AnnihilationNumber","text":"AnnihilationNumber\n\nRepresents the annihilation number of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.AverageDegree","page":"Invariants","title":"GraphProperties.Invariants.AverageDegree","text":"AverageDegree\n\nRepresents the average degree of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.ChromaticNumber","page":"Invariants","title":"GraphProperties.Invariants.ChromaticNumber","text":"ChromaticNumber\n\nRepresents the number of colors in a minimum proper coloring of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.CliqueNumber","page":"Invariants","title":"GraphProperties.Invariants.CliqueNumber","text":"CliqueNumber\n\nRepresents the cardinality of a maximum clique of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.Diameter","page":"Invariants","title":"GraphProperties.Invariants.Diameter","text":"Diameter\n\nRepresents the diameter of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.DominationNumber","page":"Invariants","title":"GraphProperties.Invariants.DominationNumber","text":"DominationNumber\n\nRepresents the cardinality of a minimum dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.EdgeDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.EdgeDominationNumber","text":"EdgeDominationNumber\n\nRepresents the cardinality of a minimum edge dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.Girth","page":"Invariants","title":"GraphProperties.Invariants.Girth","text":"Girth\n\nRepresents the girth of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.HavelHakimiResidue","page":"Invariants","title":"GraphProperties.Invariants.HavelHakimiResidue","text":"HavelHakimiResidue\n\nRepresents the Havel-Hakimi residue of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.IndependenceNumber","page":"Invariants","title":"GraphProperties.Invariants.IndependenceNumber","text":"IndependenceNumber\n\nRepresents the cardinality of a maximum independent set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.IndependentDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.IndependentDominationNumber","text":"IndependentDominationNumber\n\nRepresents the cardinality of a minimum independent dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.LocatingDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.LocatingDominationNumber","text":"LocatingDominationNumber\n\nRepresents the cardinality of a minimum locating dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MatchingNumber","page":"Invariants","title":"GraphProperties.Invariants.MatchingNumber","text":"MatchingNumber\n\nRepresents the cardinality of a maximum matching of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MaximumClique","page":"Invariants","title":"GraphProperties.Invariants.MaximumClique","text":"MaximumClique\n\nRepresents a maximum clique of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MaximumDegree","page":"Invariants","title":"GraphProperties.Invariants.MaximumDegree","text":"MaximumDegree\n\nRepresents the maximum degree of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MaximumIndependentSet","page":"Invariants","title":"GraphProperties.Invariants.MaximumIndependentSet","text":"MaximumIndependentSet\n\nRepresents a maximum independent set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MaximumMatching","page":"Invariants","title":"GraphProperties.Invariants.MaximumMatching","text":"MaximumMatching\n\nRepresents a maximum matching of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumDegree","page":"Invariants","title":"GraphProperties.Invariants.MinimumDegree","text":"MinimumDegree\n\nRepresents the minimum degree of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumDominatingSet","text":"MinimumDominatingSet\n\nRepresents a minimum dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumEdgeDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumEdgeDominatingSet","text":"MinimumEdgeDominatingSet\n\nRepresents a minimum edge dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumIndependentDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumIndependentDominatingSet","text":"MinimumIndependentDominatingSet\n\nRepresents a minimum independent dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumLocatingDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumLocatingDominatingSet","text":"MinimumLocatingDominatingSet\n\nRepresents a minimum locating dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumPairedDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumPairedDominatingSet","text":"MinimumPairedDominatingSet\n\nRepresents a minimum paired dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumPowerDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumPowerDominatingSet","text":"MinimumPowerDominatingSet\n\nRepresents a minimum power dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumProperColoring","page":"Invariants","title":"GraphProperties.Invariants.MinimumProperColoring","text":"MinimumProperColoring\n\nRepresents a minimum proper coloring of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumTotalDominatingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumTotalDominatingSet","text":"MinimumTotalDominatingSet\n\nRepresents a minimum total dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.MinimumZeroForcingSet","page":"Invariants","title":"GraphProperties.Invariants.MinimumZeroForcingSet","text":"MinimumZeroForcingSet\n\nRepresents a minimum zero forcing set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.Order","page":"Invariants","title":"GraphProperties.Invariants.Order","text":"Order\n\nRepresents the number of nodes in a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.PairedDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.PairedDominationNumber","text":"PairedDominationNumber\n\nRepresents the cardinality of a minimum paired dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.PowerDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.PowerDominationNumber","text":"PowerDominationNumber\n\nRepresents the cardinality of a minimum power dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.Radius","page":"Invariants","title":"GraphProperties.Invariants.Radius","text":"Radius\n\nRepresents the radius of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.Size","page":"Invariants","title":"GraphProperties.Invariants.Size","text":"Size\n\nRepresents the number of edges in a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.SlaterNumber","page":"Invariants","title":"GraphProperties.Invariants.SlaterNumber","text":"SlaterNumber\n\nRepresents the Slater number of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.SubKDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.SubKDominationNumber","text":"SubKDominationNumber\n\nRepresents the sub-k domination number of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.SubTotalDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.SubTotalDominationNumber","text":"SubTotalDominationNumber\n\nRepresents the sub-total domination number of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.TotalDominationNumber","page":"Invariants","title":"GraphProperties.Invariants.TotalDominationNumber","text":"TotalDominationNumber\n\nRepresents the cardinality of a minimum total dominating set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#GraphProperties.Invariants.ZeroForcingNumber","page":"Invariants","title":"GraphProperties.Invariants.ZeroForcingNumber","text":"ZeroForcingNumber\n\nRepresents the cardinality of a minimum zero forcing set of a graph.\n\n\n\n\n\n","category":"type"},{"location":"invariants/#Base.:==-Tuple{AbstractOptimalEdgeSet, AbstractOptimalEdgeSet}","page":"Invariants","title":"Base.:==","text":"==(\n    a::AbstractOptimalEdgeSet,\n    b::AbstractOptimalEdgeSet\n)::Bool\n\nDetermine if two sets of edges are equivalent in an undirected graph context.\n\nThis method treats each edge as undirected, meaning the order of vertices in each edge tuple or Graphs.SimpleGraphs.SimpleEdge is ignored. Two sets of edges are considered equal if they contain the same pairs of vertices, regardless of the order in which the vertices appear in each edge.\n\nImplementation Notes\n\nIt does not matter if the input sets of edges are of different concrete types, as long as they are both subtypes of AbstractOptimalEdgeSet. See the example below.\n\nArguments\n\na::AbstractOptimalEdgeSet: The first set of edges to compare.\nb::AbstractOptimalEdgeSet: The second set of edges to compare.\n\nReturns\n\ntrue if both sets of edges represent the same undirected connections, false otherwise.\n\nExamples\n\njulia> using Graphs.SimpleGraphs: SimpleEdge\n\njulia> using GraphProperties.Invariants\n\njulia> a = MaximumMatching([SimpleEdge(1, 2), SimpleEdge(2, 3)]);\n\njulia> b = MinimumEdgeDominatingSet([SimpleEdge(2, 1), SimpleEdge(3, 2)]);\n\njulia> a == b\ntrue\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.clique_number-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.clique_number","text":"function clique_number(g::AbstractGraph; optimizer=HiGHS.Optimizer)\n\nReturn the clique number of g.\n\nA clique of a graph g is a subset of the vertices of g such that every two distinct vertices in the clique are adjacent. The clique number of g is the cardinality of a maximum clique of g.\n\nImplementation Notes\n\nComputes the independence number of the complement of g.\n\nArguments\n\ng::AbstractGraph: The graph to compute the clique number of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the maximum independent set problem.\n\nReturns\n\nThe clique number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> clique_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{GraphProperties.Invariants.BruteForceMinimumZeroForcingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{BruteForceMinimumZeroForcingSet}, g::AbstractGraph)\n\nReturn a minimum zero forcing set of g using a brute force method. \n\nThis method assures correctness, but is not efficient for large graphs. A set of nodes is considered zero forcing if it can force all nodes in the graph to be colored by the following rules:     - If a node is colored, it remains colored.     - If a node is colored and has exactly one uncolored neighbor, that neighbor is       colored. A minimum zero forcing set is a zero forcing set of minimum cardinality.\n\nArguments\n\ng::AbstractGraph: The input graph.\n\nReturns\n\nA minimum zero forcing set of g.\n\nExamples\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> compute(BruteForceMinimumZeroForcingSet, g)\nBruteForceMinimumZeroForcingSet([1])\n\njulia> h = Graphs.complete_graph(4)\n{4, 6} undirected simple Int64 graph\n\njulia> compute(BruteForceMinimumZeroForcingSet, h)\nBruteForceMinimumZeroForcingSet([1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MaximumClique}, Graphs.AbstractGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MaximumClique}, g::AbstractGraph{T}; optimizer=HiGHS.Optimizer)\n\nReturn the maximum clique of g.\n\nA clique of a graph g is a subset of the vertices of g such that every two distinct vertices in the clique are adjacent. A maximum clique is a clique of the largest possible size.\n\nArguments\n\ng::AbstractGraph{T}: The graph to compute the maximum clique of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the maximum clique problem.\n\nReturns\n\nA MaximumClique object representing the maximum clique of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> compute(MaximumClique, g)\nMaximumClique([1, 5])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MaximumIndependentSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"function compute(\n    ::Type{MaximumIndependentSet},\n    g::AbstractGraph{T};\n    optimizer=Cbc.Optimizer,\n) where T <: Integer\n\nObtain a maximum independent set of g.\n\nImplementation Notes\n\nThe independent set is found by solving the following linear program:\n\nbeginalign*\n    max_i in mathbbZ  sumlimits_v in V x_v \r\n    textst  x_v in 0 1  forall v in V \r\n     x_u + x_v leq 1  forall uv in E\nendalign*\n\nArguments\n\ng::AbstractGraph{T}: The graph to compute the maximum independent set of.\n\nKeywords\n\noptimizer=Cbc.Optimizer: The optimizer to use to solve the maximum independent set problem.\n\nReturns\n\nA MaximumIndependentSet object representing the maximum independent set of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> compute(MaximumIndependentSet, g)\nMaximumIndependentSet([1, 3, 5])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MaximumMatching}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MaximumMatching}, g::SimpleGraph{T}; optimizer=HiGHS.Optimizer) where T <: Integer\n\nReturn a maximum matching of g.\n\nA matching of a graph g is a subset of the edges of g such that no two edges share a common vertex. A matching is said to be maximum if it has the largest possible cardinality among all matchings of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute a maximum matching of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the maximum matching problem.\n\nReturns\n\nA maximum matching of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> compute(MaximumMatching, g)\nMaximumMatching(Graphs.SimpleGraphs.SimpleEdge{Int64}[Edge 1 => 2, Edge 3 => 4])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumDominatingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(\n    ::Type{MinimumDominatingSet},\n    g::AbstractGraph{T};\n    optimizer=HiGHS.Optimizer\n) where T <: Integer\n\nReturn a minimum dominating set of g.\n\nA dominating set of a graph g is a subset S of the vertices of g such that every vertex not in S is adjacent to at least one member of S. A dominating set is said to be minimum if it has the smallest possible cardinality among all dominating sets of g.\n\nArguments\n\ng::AbstractGraph{T}: The graph to compute the minimum dominating set of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum dominating set problem.\n\nReturns\n\nA MinimumDominatingSet object representing the minimum dominating set of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> compute(MinimumDominatingSet, g)\nMinimumDominatingSet([2, 5])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumEdgeDominatingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MinimumEdgeDominatingSet}, g::SimpleGraph{T}; optimizer=HiGHS.Optimizer)\n\nReturn a minimum edge dominating set of g.\n\nAn edge dominating set of a graph g is a subset S of the edges of g such that every edge in g is either in S or adjacent to an edge in S. A minimum edge dominating set is an edge dominating set of smallest possible cardinality.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the minimum edge dominating set of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the optimization problem.\n\nReturns\n\nA MinimumEdgeDominatingSet object representing the minimum edge dominating set of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> compute(MinimumEdgeDominatingSet, g)\nMinimumEdgeDominatingSet(Graphs.SimpleGraphs.SimpleEdge{Int64}[Edge 1 => 5, Edge 2 => 3])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumPowerDominatingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MinimumZeroForcingSet}, g::SimpleGraph)\n\nReturn a minimum zero forcing set of g.\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumProperColoring}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(\n    ::Type{MinimumProperColoring},\n    g::SimpleGraph{T};\n    optimizer = HiGHS.Optimizer\n) where T <: Integer\n\nReturn the minimum proper coloring of g by solving a Binary Program.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the minimum proper coloring of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum proper coloring problem.\n\nReturns\n\nA MinimumProperColoring object representing the minimum proper coloring of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = SimpleGraph(5)\n{5, 0} undirected simple Int64 graph\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 1, 4);\n\njulia> add_edge!(g, 1, 5);\n\njulia> compute(MinimumProperColoring, g)\nMinimumProperColoring(Dict(5 => 2, 4 => 2, 2 => 2, 3 => 2, 1 => 1))\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumTotalDominatingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(\n    ::Type{MinimumTotalDominatingSet},\n    g::SimpleGraph{T};\n    optimizer=HiGHS.Optimizer\n) where T <: Integer\n\nReturn a minimum total dominating set of g.\n\nA total dominating set of a graph g is a subset S of the vertices of g such that every vertex in g is adjacent to at least one member of S. A total dominating set is said to be minimum if it has the smallest possible cardinality among all total dominating sets of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the minimum total dominating set of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the optimization problem.\n\nReturns\n\nA MinimumTotalDominatingSet object representing the minimum total dominating set of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> compute(MinimumTotalDominatingSet, g)\nMinimumTotalDominatingSet([2, 3, 4])\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumZeroForcingSet}, Graphs.SimpleGraphs.SimpleDiGraph{T}}, Tuple{Type{MinimumZeroForcingSet}, Graphs.SimpleGraphs.SimpleDiGraph{T}, Any}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MinimumZeroForcingSet}, g::SimpleGraph)\n\nReturn a minimum zero forcing set of the graph g \n\nThis method uses an Integer Programming formulation from Brimkov et al. (2019), published in EJOR.\n\nImplementation Notes\n\nThis method uses the HiGHS optimizer to solve the Integer Program by deafault and has encountered some issues with this optimizer. If you encounter issues, try using a different optimizer.\n\nArguments\n\ng::DiGraph{T}: The input graph, with directed edges.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum zero forcing set problem.\n\nExample\n\njulia> using Graphs\n\njulia> h = Graphs.complete_graph(4)\n{4, 6} undirected simple Int64 graph\n\njulia> directed_h = Graphs.DiGraph(h)\n{4, 12} directed simple Int64 graph\n\njulia> compute(MinimumZeroForcingSet, directed_h)\nMinimumZeroForcingSet(Set{Int64}([1, 2, 3]))\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.compute-Union{Tuple{T}, Tuple{Type{MinimumZeroForcingSet}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.compute","text":"compute(::Type{MinimumZeroForcingSet}, g::SimpleGraph)\n\nReturn a minimum zero forcing set of the graph g \n\nThis method uses an Integer Programming formulation from Brimkov et al. (2019), published in EJOR.\n\nImplementation Notes\n\nThis method converts the input graph to a directed graph, replacing each edge with two directed edges. If the input graph is already directed, a different method is used. This method uses the HiGHS optimizer to solve the Integer Program by deafault and has encountered some issues with this optimizer. If you encounter issues, try using a different optimizer.\n\nArguments\n\ng::SimpleGraph: The input graph.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum zero forcing set problem.\n\nExample\n\njulia> using Graphs\n\njulia> h = Graphs.complete_graph(4)\n{4, 6} undirected simple Int64 graph\n\njulia> compute(MinimumZeroForcingSet, h)\nMinimumZeroForcingSet(Set{Int64}([1, 2, 3]))\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.domination_number","text":"domination_number(g::SimpleGraph; optimizer=HiGHS.Optimizer)})\n\nReturn the domination number of g.\n\nA dominating set of a graph g is a subset S of the vertices of g such that every vertex in g is either in S or adjacent to a vertex in S. The domination number of g is the cardinality of a minimum dominating set of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the domination number of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum dominating set problem.\n\nReturns\n\nThe domination number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> domination_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.edge_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.edge_domination_number","text":"edge_domination_number(g::SimpleGraph{T}; optimizer=HiGHS.Optimizer)\n\nReturn the edge domination number of g.\n\nAn edge dominating set of a graph g is a subset S of the edges of g such that every edge in g is incident to at least one edge in S. The edge domination number of g is the cardinality of a minimum edge dominating set of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the edge domination number of.\n\nReturns\n\nThe edge domination number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> edge_domination_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.independence_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.independence_number","text":"function independence_number(\n    g::SimpleGraph{T};\n    optimizer=Cbc.Optimizer,\n) where T <: Integer\n\nReturn the independence number of g.\n\nImplementation Notes\n\nThis function relies on compute to obtain a maximum independent set of g. The optimizer is passed to max_independent_set.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the independence number of.\n\nKeywords\n\noptimizer=Cbc.Optimizer: The optimizer to use to solve the maximum independent set problem.\n\nReturns\n\nThe independence number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> independence_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.independent_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.independent_domination_number","text":"compute(::Type{IndependentDominationNumber}, g::SimpleGraph{T}; optimizer=HiGHS.Optimizer)\n\nReturn the independent domination number of g.\n\nAn independent dominating set of a graph g is a subset S of the vertices of g such that every vertex in g is either in S or adjacent to a vertex in S, and S forms an independent set in g. The independent domination number of g is the cardinality of a minimum independent dominating set of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the independent domination number of.\n\nReturns\n\nThe independent domination number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> independent_domination_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.matching_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.matching_number","text":"matching_number(g::SimpleGraph; optimizer=HiGHS.Optimizer)\n\nReturn the matching number of g. \n\nA matching of a graph g is a subset of the edges of g such that no two edges in the matching share a vertex. The matching number of g is the cardinality of a maximum matching of g.\n\nArguments\n\ng::SimpleGraph: The graph to compute the matching number of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the maximum matching problem.\n\nReturns\n\nThe matching number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> matching_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.power_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.power_domination_number","text":"power_domination_number(g::SimpleGraph{T})\n\nReturn the power domination number of g.\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.total_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.total_domination_number","text":"total_domination_number(g::SimpleGraph{T}; optimizer=HiGHS.Optimizer)\n\nReturn the total domination number of g.\n\nA total dominating set of a graph g is a subset S of the vertices of g such that every vertex in g is adjacent to at least one vertex in S. The total domination number of g is the cardinality of a minimum total dominating set of g.\n\nArguments\n\ng::SimpleGraph{T}: The graph to compute the total domination number of.\n\nKeywords\n\noptimizer=HiGHS.Optimizer: The optimizer to use to solve the minimum total dominating set problem.\n\nReturns\n\nThe total domination number of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Invariants\n\njulia> g = cycle_graph(5)\n{5, 5} undirected simple Int64 graph\n\njulia> total_domination_number(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"invariants/#GraphProperties.Invariants.zero_forcing_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Invariants","title":"GraphProperties.Invariants.zero_forcing_number","text":"zero_forcing_number(g::AbstractGraph{T}) where T <: Integer\n\nReturn the zero forcing number of g.\n\nA set of nodes in a graph g is a zero forcing set if it can force all nodes in the graph  to be colored by the following rules:     - If a node is colored, it remains colored.     - If a node is colored and has exactly one uncolored neighbor, that neighbor is       colored. A minimum zero forcing set is a zero forcing set of minimum cardinality. The zero forcing number of g is the cardinality of a minimum zero forcing set of g.\n\n###Implementation Notes This method uses an Integer Programming formulation from Brimkov et al. (2019). For a brute force method, see compute(BruteForceMinimumZeroForcingSet, g).\n\nArguments\n\ng::AbstractGraph{T}: The graph to compute the zero forcing number of.\n\nReturns\n\nThe zero forcing number of g.\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#Degree-Sequence-Invariants","page":"Degree Sequence Invariants","title":"Degree Sequence Invariants","text":"","category":"section"},{"location":"degree_sequence_invariants/","page":"Degree Sequence Invariants","title":"Degree Sequence Invariants","text":"The DegreeSequenceInvariants module provides types and methods for analyzing invariants related to the degree sequence of a graph.","category":"page"},{"location":"degree_sequence_invariants/","page":"Degree Sequence Invariants","title":"Degree Sequence Invariants","text":"Modules = [GraphProperties.DegreeSequenceInvariants]","category":"page"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.annihilation_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.annihilation_number","text":"annihilation_number(g::SimpleGraph)\n\nReturn the annihilation number of the graph g.\n\nThe annihilation number of a graph g is the largest integer k such that the sum of the k smallest degrees in g is less than or equal to the number of edges in g.\n\nArguments\n\ng::SimpleGraph: A simple graph.\n\nReturns\n\nThe annihilation number of the graph g.\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.average_degree-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.average_degree","text":"average_degree(g::AbstractGraph{T}) where T <: Integer\n\nReturn the (arithmetic) average degree of g.\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.havel_hakimi_residue-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.havel_hakimi_residue","text":"havel_hakimi_residue(g::SimpleGraph)\n\nReturn the Havel-Hakimi residue of the graph g.\n\nThe Havel-Hakimi residue of a graph g is the length of the degree sequence after applying the Havel-Hakimi rule to the degree sequence of g. This method returns the length of the final sequence after applying the Havel-Hakimi rule as long as it may be applied.\n\nArguments\n\ng::SimpleGraph: A simple graph.\n\nReturns\n\nThe Havel-Hakimi residue of the graph g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.DegreeSequenceInvariants\n\njulia> g = PathGraph(5);\n\njulia> havel_hakimi_residue(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.maximum_degree-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.maximum_degree","text":"maximum_degree(g::AbstractGraph{T}) where T <: Integer\n\nReturn the maximum degree of g.\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.minimum_degree-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.minimum_degree","text":"minimum_degree(g::AbstractGraph{T},) where T <: Integer\n\nReturn the minimum degree of g.\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.slater_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.slater_number","text":"slater_number(g::SimpleGraph{T},) where T <: Integer\n\nReturn the Slater invariant for the graph g.\n\nThe Slater invariant of a graph g is the sub-k-domination number of g where k = 1.\n\nArguments\n\ng::SimpleGraph: A simple graph.\n\nReturns\n\nThe Slater invariant of the graph g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.DegreeSequenceInvariants\n\njulia> g = PathGraph(5);\n\njulia> slater_number(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.sub_k_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.sub_k_domination_number","text":"function sub_k_domination_number(\n    g::SimpleGraph{T};\n    k::Integer = 1,\n) where T <: Integer\n\nReturn the sub-k-domination number of the graph g.\n\nThe sub-k-domination number of a graph g is the smallest integer t such that the sum  of the degrees of the first t vertices in the sorted degree sequence with t is at least  n. Scaling by 1/k. Please see the following reference for more information: D. Amos et al., \"The  sub-k-domination number of a graph with applications to k-domination\", arXiv preprint arXiv:1611.02379, (2016)\n\nArguments\n\ng::SimpleGraph: A simple graph.\nk::Integer: The scaling factor.\n\nReturns\n\nThe sub-k-domination number of the graph g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.DegreeSequenceInvariants\n\njulia> g = PathGraph(5);\n\njulia> sub_k_domination_number(g, k=1)\n2\n\n\n\n\n\n","category":"method"},{"location":"degree_sequence_invariants/#GraphProperties.DegreeSequenceInvariants.sub_total_k_domination_number-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Degree Sequence Invariants","title":"GraphProperties.DegreeSequenceInvariants.sub_total_k_domination_number","text":"sub_total_k_domination_number(\n    g::SimpleGraph{T};\n    k::Integer = 1,\n) where T <: Integer\n\nReturn the sub-total domination number of the graph g.\n\nThe sub-total domination number of a graph g is the smallest integer t such that the sum of the degrees of the first t vertices in the sorted degree sequence with t is at least k * n where n is the number of vertices in g and k is just used for scaling  Please see the following reference for more information: R. Davila, \"A note on sub-total  domination in graphs\", arXiv preprint arXiv:1701.07811, (2017)\n\nArguments\n\ng::SimpleGraph: A simple graph.\nk::Integer: The scaling factor.\n\nReturns\n\nThe sub-total domination number of the graph g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.DegreeSequenceInvariants\n\njulia> g = CompleteGraph(6);\n\njulia> sub_total_k_domination_number(g, k=1)\n2\n\n\n\n\n\n","category":"method"},{"location":"communities/#Communities","page":"Communities","title":"Communities","text":"","category":"section"},{"location":"communities/","page":"Communities","title":"Communities","text":"This module contains functions for community detection algorithms and related operations. Most code is derived from the Graph Communities Julia Package. Algorithms include label propagation, pagerank, k-clique, and others. The module also includes other methods for graph construction, community analysis, and visualization.","category":"page"},{"location":"communities/","page":"Communities","title":"Communities","text":"Modules = [GraphProperties.Communities]","category":"page"},{"location":"communities/#GraphProperties.Communities.ChainedCliques","page":"Communities","title":"GraphProperties.Communities.ChainedCliques","text":"ChainedCliques <: CommunityGraph\n\nA graph structure that represents a series of connected cliques.\n\nFields\n\nnum_cliques::Int: The number of cliques in the graph.\nclique_size::Int: The number of nodes in each clique.\n\nExamples\n\ngraph_info = ChainedCliques(num_cliques=5, clique_size=4)\ngraph = generate(graph_info)\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.CommunityDetectionAlgorithm","page":"Communities","title":"GraphProperties.Communities.CommunityDetectionAlgorithm","text":"CommunityDetectionAlgorithm\n\nAbstract type representing a community detection algorithm. This serves as the base type for various community detection algorithms implemented in the package.\n\nNotes\n\nAll custom community detection algorithms in the package should subtype this abstract type. See Louvain, KClique, etc. for concrete implementations.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.CommunityGraph","page":"Communities","title":"GraphProperties.Communities.CommunityGraph","text":"CommunityGraph\n\nAn abstract type representing a graph with community structure.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.FastLPA","page":"Communities","title":"GraphProperties.Communities.FastLPA","text":"FastLPA <: CommunityDetectionAlgorithm\n\nThe (Fast) Label Propagation algorithm for community detection in networks.\n\nThe Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.\n\nThe algorithm can be run in either synchronous or asynchronous mode:\n\nSynchronous: All nodes update their labels simultaneously in each iteration.\nAsynchronous: Nodes update their labels in a random order (not yet implemented).\n\nArguments\n\nsynchronous::Bool: If true, updates labels in synchronous mode; if false (default),\n\nupdates labels in asynchronous mode.\n\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't\n\nconverge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\ncommunities = compute(FastLPA(), graph)            # Synchronous (default)\n\nReferences\n\nRaghavan, U. N., Albert, R., & Kumara, S. (2007). Near linear time algorithm to detect\n\ncommunity structures in large-scale networks. Physical review E, 76(3), 036106.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.KClique","page":"Communities","title":"GraphProperties.Communities.KClique","text":"KClique <: CommunityDetectionAlgorithm\n\nThe K-Clique Percolation algorithm for community detection in networks.\n\nThis method identifies communities based on the presence of K-clique (with K = 3) structures within the graph, where a K-clique is a fully connected subgraph of K nodes. Two K-cliques are adjacent if they share K-1 nodes, and a community is defined as the union of K-cliques that can be reached from each other through a series of adjacent K-cliques.\n\nUsage\n\ncommunities = compute(KClique(), graph)\n\nReferences\n\nPalla, G., Derényi, I., Farkas, I., & Vicsek, T. (2005). Uncovering the overlapping community structure of complex networks in nature and society. Nature, 435(7043), 814-818.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.KarateClub","page":"Communities","title":"GraphProperties.Communities.KarateClub","text":"KarateClub <: CommunityGraph\n\nThe KarateClub graph, often referred to as the \"Zachary's Karate Club\", is a social network of friendships between 34 members of a karate club at a US university in the 1970s. This dataset has become a standard benchmark in community detection literature because of its well-documented community structure.\n\nThe graph captures the observed friendships between the 34 members. During the course of the study, the club split into two communities due to a conflict, making it a valuable dataset for studying community detection algorithms.\n\nUsage\n\ngraph = generate(KarateClub())\n\nReferences\n\nZachary, W. W. (1977). An information flow model for conflict and fission in small groups. Journal of anthropological research, 452-473.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.LabelPropagation","page":"Communities","title":"GraphProperties.Communities.LabelPropagation","text":"LabelPropagation <: CommunityDetectionAlgorithm\n\nThe Label Propagation algorithm for community detection in networks.\n\nThe Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.\n\nThe algorithm can be run in either synchronous or asynchronous mode:\n\nSynchronous: All nodes update their labels simultaneously in each iteration.\nAsynchronous: Nodes update their labels in a random order.\n\nArguments\n\nsynchronous::Bool: If true, updates labels in synchronous mode; if false (default),\n\nupdates labels in asynchronous mode.\n\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't\n\nconverge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\ncommunities = compute(LabelPropagation(), graph)            # Asynchronous (default)\ncommunities = compute(LabelPropagation(sync=true), graph)   # Synchronous\n\nReferences\n\nRaghavan, U. N., Albert, R., & Kumara, S. (2007). Near linear time algorithm to detect\n\ncommunity structures in large-scale networks. Physical review E, 76(3), 036106.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.Louvain","page":"Communities","title":"GraphProperties.Communities.Louvain","text":"Louvain <: CommunityDetectionAlgorithm\n\nThe Louvain algorithm for community detection in networks.\n\nThis method optimizes the modularity of partitions of the graph. It follows a greedy optimization approach that generally operates in time (O(n \\log n)) , making it efficient for large-scale networks.\n\nUsage\n\ncommunities = compute(Louvain(), graph)\n\nReferences\n\nBlondel, V. D., Guillaume, J. L., Lambiotte, R., & Lefebvre, E. (2008). Fast unfolding\n\nof communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.PageRank","page":"Communities","title":"GraphProperties.Communities.PageRank","text":"PageRank <: CommunityDetectionAlgorithm\n\nPageRank is an algorithm originally designed for ranking web pages in search results. However, it can also be used more broadly in networks to determine the importance of nodes within a graph. The underlying principle is that more important nodes are likely to receive more links from other nodes.\n\nThe algorithm computes a stationary distribution of a random walk on the graph where, at each step, with probability d, the walker randomly chooses an outgoing link from its current node and with probability 1 - d, it jumps to a random node in the graph.\n\nArguments\n\nd::Float64: Damping factor (default is 0.85). It represents the probability that the random walker follows an outgoing edge. Typically set between 0.85 and 0.9.\ntol::Float64: Tolerance for determining convergence (default is 1e-6). The algorithm stops iterating once the change between subsequent PageRank vectors is below this value.\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't converge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\npageranks = compute(PageRank(), graph)  # Using default parameters\npageranks = compute(PageRank(d=0.9, tol=1e-7, max_iter=150), graph)\n\nReferences\n\nPage, L., Brin, S., Motwani, R., & Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities.PlantedPartition","page":"Communities","title":"GraphProperties.Communities.PlantedPartition","text":"PlantedPartition <: CommunityGraph\n\nThe PlantedPartition model, also known as the Stochastic Block Model (SBM), is a probabilistic model commonly used for generating synthetic networks with inherent community structures. This model creates a graph by partitioning nodes into distinct communities and then adding edges between nodes based on intra-community and inter-community probabilities.\n\nArguments\n\nn_communities::Int: Number of communities or blocks in the graph.\nnodes_per_community::Int: Number of nodes within each community.\npintra::Float64: Probability of creating an edge between two nodes within the same community. This defines the density of intra-community edges.\npinter::Float64: Probability of creating an edge between two nodes from different communities. This defines the sparsity of inter-community edges.\n\nTypically, pintra is set to be much larger than pinter to ensure dense intra-community connections and sparse inter-community connections, thereby creating discernible community structures.\n\nUsage\n\ngraph1 = generate(PlantedPartition())  # Using default parameters\ngraph2 = generate(PlantedPartition(n_communities=5, nodes_per_community=10, pintra=0.8, pinter=0.02))\n\nReferences\n\nHolland, P. W., Laskey, K. B., & Leinhardt, S. (1983). Stochastic blockmodels: First steps. Social networks, 5(2), 109-137.\n\n\n\n\n\n","category":"type"},{"location":"communities/#GraphProperties.Communities._adaptive_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}","page":"Communities","title":"GraphProperties.Communities._adaptive_regularization_pagerank","text":"_adaptive_pagerank(\n    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}\n\nHelper function for compute(Pagerank, g), computes the PageRank values of the nodes in graph g using the adaptive regularization PageRank algorithm.\n\nArguments\n\nP::SparseMatrixCSC: The Markov Chain associated with g.\nd::Float64: The initial damping factor. 0 < d < 1.0\ntol::Float64: The tolerance for convergence.\nmax_iter::Int64: The maximum number of iterations.\n\nReturns\n\nA vector of Float64 where each entry represents the PageRank value of the corresponding node in the graph.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._classical_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}","page":"Communities","title":"GraphProperties.Communities._classical_pagerank","text":"_classical_pagerank(\n    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}\n\nHelper function for compute(Pagerank, g), computes the PageRank values of the nodes in     graph g using the classical PageRank algorithm.\n\nArguments\n\nP::SparseMatrixCSC: The Markov Chain associated with g.\nd::Float64: The damping factor.\ntol::Float64: The tolerance for convergence.\nmax_iter::Int64: The maximum number of iterations.\n\nReturns\n\nA vector of Float64 where each entry represents the PageRank value of the   corresponding node in the graph.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}","page":"Communities","title":"GraphProperties.Communities._draw_communities","text":"draw_communities(g::AbstractGraph, communities::Dict{Int, Int})\n\nInternal function to draw the graph g with nodes colored based on their community assignments.\n\nThis function maps each unique community label to a distinct color and then generates a plot where each node in the graph g is colored according to its community label.\n\nArguments\n\ng::AbstractGraph: The input graph.\ncommunities::Dict{Int, Int}: A dictionary mapping each vertex to its community label.\n\nReturns\n\nA plot object with nodes colored based on their community label. Each unique community is represented by a unique color.\n\nNotes\n\nThis function is an internal helper and is typically not called directly by users. It is used by higher-level community drawing functions which prepare and pass the community mapping in the form of a dictionary.\nThe function assumes that every vertex in the graph g is assigned a community label in the communities dictionary. If any vertex is missing a label, an error will be raised in the calling function.\nThe colors are chosen to be as distinguishable as possible, but for graphs with a very large number of communities, some colors may be similar.\n\nExample\n\njulia> g = generate(KarateClub())\n\njulia> communities = compute(LabelPropagation(), g)\n\njulia> draw_communities(g, communities)\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._iterative_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}","page":"Communities","title":"GraphProperties.Communities._iterative_regularization_pagerank","text":"_iterative_pagerank(\n    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}\n\nHelper function for compute(Pagerank, g), computes the PageRank values of the nodes in     graph g using the iterative regularization PageRank algorithm.\n\nArguments\n\nP::SparseMatrixCSC: The Markov Chain associated with g.\nd::Float64: The initial damping factor, from which the regularization factor is computed. 0 < d < .5\ntol::Float64: The tolerance for convergence.\nmax_iter::Int64: The maximum number of iterations.\n\nReturns\n\nA vector of Float64 where each entry represents the PageRank value of the corresponding node in the graph.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._label_propagation_sweep!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Tuple{Int64, Int64}}}","page":"Communities","title":"GraphProperties.Communities._label_propagation_sweep!","text":"_label_propagation_sweep!(\n    pres_labels::Vector{Int},\n    next_labels::Vector{Int},\n    seen_labels::Vector{Int},\n    seen_label_counts::Vector{Int},\n    edge_list::Vector{Tuple{Int,Int}}\n)::Bool\n\nPerforms a single sweep of label propagation on a graph.\n\nThis function updates the labels of vertices based on the most frequent labels among their neighbors, using a provided edge list.\n\nArguments\n\npres_labels::Vector{Int}: The current labels of the vertices.\nnext_labels::Vector{Int}: The vector to store the updated labels.\nseen_labels::Vector{Int}: A buffer vector to store observed neighbor labels.\nseen_label_counts::Vector{Int}: A vector to count occurrences of each label.\nedge_list::Vector{Tuple{Int,Int}}: The list of edges in the graph.\n\nReturns\n\ntrue if the labeling has reached a stationary state (no changes), false otherwise.\n\nNotes\n\nAssumes the edge list is lexicographically ordered.\nEdges are processed sequentially, and labels are updated based on the most frequent neighbor labels.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._max_argmax_in_seen-Tuple{Vector{Int64}, Vector{Int64}, Int64}","page":"Communities","title":"GraphProperties.Communities._max_argmax_in_seen","text":"_max_argmax_in_seen(\n    seen_label_counts::Vector{Int},\n    seen_labels::Vector{Int},\n    n_seen_labels::Int\n)::Int\n\nFinds the maximum label with the highest count among seen labels.\n\nThis function is used in the label propagation algorithm to determine the most popular label among a node's neighbors.\n\nArguments\n\nseen_label_counts::Vector{Int}: A vector containing counts of each label seen.\nseen_labels::Vector{Int}: The labels that have been seen in the current context.\nn_seen_labels::Int: The number of seen labels to consider.\n\nReturns\n\nThe label with the highest count among the seen labels. In case of a tie, the highest label is chosen.\n\nNotes\n\nThis function is part of the internal mechanics of label propagation and operates on a subset of labels.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities._max_argmax_in_seen_weighted-Tuple{Vector{Float64}, Vector{Int64}, Int64}","page":"Communities","title":"GraphProperties.Communities._max_argmax_in_seen_weighted","text":"_max_argmax_in_seen_weighted(\n    seen_label_weights::Vector{Float64},\n    seen_labels::Vector{Int},\n    n_seen_labels::Int\n)::Int\n\nFinds the maximum label with the highest accumulated weight among seen labels.\n\nThis function is used in the label propagation algorithm for weighted graphs to determine the most 'influential' label among a node's neighbors, based on the weights of the edges connecting to those neighbors.\n\nArguments\n\nseen_label_weights::Vector{Float64}: A vector containing the accumulated weights for each label seen.\nseen_labels::Vector{Int}: The labels that have been seen in the current context.\nn_seen_labels::Int: The number of seen labels to consider.\n\nReturns\n\nThe label with the highest accumulated weight among the seen labels. In case of a tie, the highest label is chosen.\n\nNotes\n\nThis function is part of the internal mechanics of label propagation for weighted graphs and operates on a subset of labels.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Graphs.SimpleGraphs.SimpleGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::FastLPA, g::SimpleGraph)\n\nExecute the Fast Label Propagation algorithm on a graph.\n\nThis function processes a SimpleGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.\n\nArguments\n\nalgo::FastLabelPropagation: The Fast Label Propagation algorithm instance.\ng::SimpleGraph: The graph to be processed, represented as a SimpleGraph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe graph g is first converted into an edge list and the number of vertices is determined.\nThis function delegates to _sync_label_propagation for the actual label propagation process.\nCurrently, only synchronous label propagation is implemented. If algo.synchronous is false, the function will return nothing.\n\nExample\n\njulia> g = generate(PlantedPartition())\n\njulia> compute(FastLPA(), g)\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, SimpleWeightedGraphs.SimpleWeightedGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::FastLPA, g::SimpleWeightedGraph)\n\nExecute the Fast Label Propagation algorithm on a graph.\n\nThis function processes a SimpleWeightedGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.\n\nArguments\n\nalgo::FastLabelPropagation: The Fast Label Propagation algorithm instance.\ng::SimpleWeightedGraph: The graph to be processed, represented as a SimpleWeightedGraph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe graph g is first converted into an edge list and the number of vertices is determined.\nThis function delegates to _sync_label_propagation for the actual label propagation process.\nCurrently, only synchronous label propagation is implemented. If algo.synchronous is false, the function will return nothing.\n\nExample\n\njulia> compute(FastLPA(), g)\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Vector{Tuple{Int64, Int64}}, Int64}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::FastLPA, edge_list::Vector{Tuple{Int,Int}}, num_vertices::Int)\n\nExecute the Fast Label Propagation algorithm using a precomputed edge list.\n\nThis variant of the compute function allows for direct input of a graph's edge list and number of vertices. It's particularly useful when the edge list has been precomputed or when working with a graph representation that doesn't conform to a SimpleGraph.\n\nArguments\n\nalgo::FastLPA: The Fast Label Propagation algorithm instance.\nedge_list::Vector{Tuple{Int,Int}}: The edge list of the graph, where each edge is represented as a tuple of vertex indices.\nnum_vertices::Int: The number of vertices in the graph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe edge list should be lexicographically sorted and represent a valid graph.\nOnly synchronous label propagation is currently implemented.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.KClique, Graphs.SimpleGraphs.SimpleGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::KClique, g::SimpleGraph)::Dict{Int, Int}\n\nDetect communities in a graph g using the K-Clique algorithm.\n\nThe function first finds triangles (or 3-cliques) in the graph. It then constructs a k-clique graph where nodes represent triangles, and edges indicate overlap. The connected components of this k-clique graph give the communities in the original graph.\n\nArguments\n\nalgo::KClique: Indicates that the K-Clique algorithm should be used for community detection.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA dictionary mapping node IDs in the original graph to their respective community IDs.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(KarateClub())\n\njulia> compute(KClique(), g)\n\nNotes\n\nCurrently, the implementation is restricted to 3-cliques (triangles). Future versions might support other clique sizes.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.LabelPropagation, Graphs.SimpleGraphs.SimpleGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::LabelPropagation, g::SimpleGraph)::LabelArray\n\nDetect communities in a graph g using the Label Propagation algorithm.\n\nThe algorithm works by initially assigning each node a unique label. Then, in each iteration, each node adopts the label that is most frequent among its neighbors. The algorithm terminates when no node changes its label or after reaching a maximum number of iterations.\n\nArguments\n\nalgo::LabelPropagation: An instance indicating the settings of the Label Propagation algorithm.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA LabelArray where each index corresponds to a vertex and its value indicates its community label.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(KarateClub())\n\njulia> communities = compute(LabelPropagation(), g)\n\nNotes\n\nThe algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.Louvain, Graphs.SimpleGraphs.SimpleGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::Louvain, g::SimpleGraph)\n\nDetect communities in a graph g using the Louvain algorithm, a method based on modularity optimization.\n\nThe algorithm consists of two phases that are repeated iteratively:\n\nLocal Phase: Each node is moved to the community that yields the highest modularity gain.\nAggregation Phase: A new graph is constructed where nodes represent communities from the previous phase.\n\nThese phases are repeated until the modularity ceases to increase significantly.\n\nArguments\n\nalgo::Louvain: Indicates that the Louvain algorithm should be used for community detection.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA dictionary mapping node IDs in the original graph to their respective community IDs.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(PlantedPartition())\n\njulia> compute(Louvain(), g)\n\nNotes\n\nThe algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.PageRank, Graphs.AbstractGraph}","page":"Communities","title":"GraphProperties.Communities.compute","text":"compute(algo::PageRank, g::AbstractGraph)::Vector{Float64}\n\nCompute the PageRank values of the nodes in graph g using the specified PageRank algorithm.\n\nArguments\n\nalgo::PageRank: The PageRank algorithm configuration object. This should contain properties like (initial) damping factor (d), maximum number of iterations (max_iter), tolerance (tol), and the method: \"classical\", \"iterative\", or \"adaptive\" (method_name). The two latter methods are described in the paper PageRank: New Regularizations and Simulation Models (2011) by Boris T. Polyak and Anna V. Timonina\ng::AbstractGraph: The graph for which to compute the PageRank. This can be a simple graph, directed or undirected, or a weighted version of these.\n\nReturns\n\nA vector of Float64 where each entry represents the PageRank value of the corresponding node in the graph.\n\nDetails\n\nThe function uses the power iteration method to find the principal eigenvector of an altered adjacency matrix. The altered matrix is created by 'damping' the original matrix, which is done by adding a constant to each entry as well as taking care of sinks. The iterative and adaptive methods increase the damping factor (decreases perturbance of P) as the algorithm progresses, which is shown to improve convergence. The iterative method increases the damping factor over a determined sequence, while the adaptive method maintains the damping factor until a relaxed tolerance is reached, then lowers the tolerance and repeats until the original tolerance is reached.\n\n```julia julia> g = generate(PlantedPartition())\n\njulia> algo = PageRank(d=0.85, maxiter=100, tol=1e-6, methodname=\"adaptive\")\n\njulia> compute(algo, g)\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}","page":"Communities","title":"GraphProperties.Communities.draw_communities","text":"draw_communities(g::AbstractGraph, communities::Dict)\n\nDraw the graph g with nodes colored based on their community assignments.\n\nArguments\n\ng::AbstractGraph: The input graph.\ncommunities::Dict: A dictionary mapping each vertex to its community.\n\nReturns\n\nA plot with nodes colored based on their community.\n\nNote\n\nThis function will only work if each node in the graph is assigned to a community.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Vector{Tuple{Int64, Int64}}}","page":"Communities","title":"GraphProperties.Communities.draw_communities","text":"draw_communities(g::AbstractGraph, node_labels::Vector{Tuple{Int, Int}})\n\nDraw the graph g with nodes colored based on their label assignments.\n\nArguments\n\ng::AbstractGraph: The input graph.\nnode_labels::Vector{Tuple{Int, Int}}: A vector of tuples, each containing a node and its label.\n\nReturns\n\nA plot with nodes colored based on their labels.\n\nExample\n\njulia> g = generate(KarateClub())\n\njulia> communities = compute(FastLPA(), g)\n\njulia> draw_communities(g, communities)\n\nNote\n\nThis function will only work if each node in the graph is included in the node_labels vector.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.find_triangles-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Communities","title":"GraphProperties.Communities.find_triangles","text":"find_triangles(g::SimpleGraph)::Set{Set{Int}}\n\nFind all the triangles in the given graph.\n\nArguments\n\ng::SimpleGraph: The input graph to search for triangles.\n\nReturns\n\nA set containing all the triangles in the graph. Each triangle is represented as a set of 3 vertices.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.ChainedCliques}","page":"Communities","title":"GraphProperties.Communities.generate","text":"generate(structure::ChainedCliques)::SimpleGraph\n\nCreate a graph consisting of structure.r cliques, each of size structure.k, chained together.\n\nstructure.r represents the number of cliques.\nstructure.k represents the size of each clique.\n\nReturns a SimpleGraph with the chained cliques.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.KarateClub}","page":"Communities","title":"GraphProperties.Communities.generate","text":"generate(structure::KarateClub)::SimpleGraph\n\nConstruct the famous Zachary's Karate Club graph. This graph represents the friendships between the 34 members of a karate club studied by Wayne W. Zachary in 1977.\n\nReturns a SimpleGraph representing the Karate Club network.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.PlantedPartition}","page":"Communities","title":"GraphProperties.Communities.generate","text":"generate(structure::PlantedPartition)::SimpleGraph\n\nGenerate a graph based on the planted partition model.\n\nstructure.n_communities is the number of communities.\nstructure.nodes_per_community denotes the number of nodes per community.\nstructure.pintra is the probability of an edge within a community.\nstructure.pinter is the probability of an edge between communities.\n\nReturns a SimpleGraph constructed based on the planted partition model.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.graph_modularity-Tuple{Graphs.SimpleGraphs.SimpleGraph, Dict{Int64, Int64}}","page":"Communities","title":"GraphProperties.Communities.graph_modularity","text":"graph_modularity(g::SimpleGraph, node_to_community::Dict{Int, Int})::Number\n\nCalculate the modularity of a graph g given a particular community assignment given by node_to_community.\n\nArguments\n\ng::SimpleGraph: The input graph.\nnode_to_community::Dict{Int, Int}: A dictionary mapping each vertex to its community.\n\nReturns\n\nFloat64: The modularity value.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.k_clique_graph-Tuple{Set{Set{Int64}}}","page":"Communities","title":"GraphProperties.Communities.k_clique_graph","text":"k_clique_graph(triangles::Set{Set{Int}})::SimpleGraph\n\nConstruct a graph where each node represents a triangle from the input set, and edges are added between nodes if their respective triangles share two vertices.\n\nArguments\n\ntriangles::Set{Set{Int}}: A set of triangles, where each triangle is represented as a set of 3 vertices.\n\nReturns\n\nA graph with nodes representing triangles and edges based on shared vertices.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.label_propagation_sweep!-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}, GraphProperties.Communities.LabelPropagation, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Communities","title":"GraphProperties.Communities.label_propagation_sweep!","text":"label_propagation_sweep!(g::SimpleGraph, labels::LabelArray, algo::LabelPropagation,\n                         X::VertexList, new_labels::LabelArray, label_counts::Vector{Int})\n\nPerform a single iteration of the Label Propagation algorithm on the provided graph.\n\nArguments\n\ng::SimpleGraph: The graph on which to detect communities.\nlabels::LabelArray: An array where each index corresponds to a vertex and its value to its community label.\nalgo::LabelPropagation: An instance indicating the settings of the Label Propagation algorithm.\nX::VertexList: A list of vertices to be considered for the propagation in the given iteration.\nnew_labels::LabelArray: An array to store new labels if the algorithm is running in synchronous mode.\nlabel_counts::LabelArray: An array to store counts of each label during propagation.\n\nNotes\n\nThe function modifies the given labels array in-place, reflecting the label changes during propagation.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.labels_to_dict-Tuple{Vector{Set{Int64}}}","page":"Communities","title":"GraphProperties.Communities.labels_to_dict","text":"labels_to_dict(labels::Vector{Set{Int}})::Dict{Int, Int}\n\nConvert a vector of sets to a dictionary mapping each element to its index in the vector.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.number_of_communities-Tuple{Vector{Int64}}","page":"Communities","title":"GraphProperties.Communities.number_of_communities","text":"number_of_communities(communities::Vector{Int64})::Int\n\nCalculate the number of unique communities in a graph.\n\nThis function takes a vector where each element represents the community assignment of a node in the graph and returns the total count of unique communities identified.\n\nArguments\n\ncommunities::Vector{Int64}: A vector with each element representing the community ID assigned to a node in the graph.\n\nReturns\n\nInt: The number of unique communities found in the graph.\n\nExample\n\njulia> community_assignments = [1, 2, 1, 3, 2, 3, 3]\n\njulia> number_of_communities(community_assignments)\n3\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.random_argmax-Tuple{AbstractArray}","page":"Communities","title":"GraphProperties.Communities.random_argmax","text":"random_argmax(arr::AbstractArray)::Int\n\nFind all indices corresponding to the maximum value of the array and randomly return one of them.\n\nArguments\n\narr::AbstractArray: An array of values.\n\nReturns\n\nAn index corresponding to a randomly selected maximum value of the array.\n\nNotes\n\nIf multiple maxima exist in the array, one of them is chosen uniformly at random.\n\n\n\n\n\n","category":"method"},{"location":"communities/#GraphProperties.Communities.update_label_counts!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Communities","title":"GraphProperties.Communities.update_label_counts!","text":"update_label_counts!(label_counts::Vector{Int}, labels::LabelArray, neighbors::VertexList)\n\nUpdate the count of labels based on the neighbors of a given vertex.\n\nArguments\n\nlabel_counts::LabelArray: An array to store the count of each label.\nlabels::LabelArray: An array where each index corresponds to a vertex and its value corresponds to its label.\nneighbors::VertexList: List of neighboring vertices for the vertex being considered.\n\nNotes\n\nThis function is used internally by label_propagation_sweep! to update the label counts for the vertices.\n\n\n\n\n\n","category":"method"},{"location":"graph_rules/#Graph-Rules","page":"Graph Rules","title":"Graph Rules","text":"","category":"section"},{"location":"graph_rules/","page":"Graph Rules","title":"Graph Rules","text":"The GraphRules module contains types and methods built for applying rules in-place.","category":"page"},{"location":"graph_rules/","page":"Graph Rules","title":"Graph Rules","text":"Modules = [GraphProperties.GraphRules]","category":"page"},{"location":"graph_rules/#GraphProperties.GraphRules.AbstractDegreeSequenceRule","page":"Graph Rules","title":"GraphProperties.GraphRules.AbstractDegreeSequenceRule","text":"AbstractDegreeSequenceRule\n\nAn abstract type that represents a rule that is applied to a degree sequence.\n\n\n\n\n\n","category":"type"},{"location":"graph_rules/#GraphProperties.GraphRules.AbstractGraphRule","page":"Graph Rules","title":"GraphProperties.GraphRules.AbstractGraphRule","text":"AbstractGraphRule\n\nAn abstract type that represents a rule that is applied to a graph.\n\n\n\n\n\n","category":"type"},{"location":"graph_rules/#GraphProperties.GraphRules.DominationRule","page":"Graph Rules","title":"GraphProperties.GraphRules.DominationRule","text":"DominationRule\n\nA rule that is applied to a graph to determine if vertices set S is a dominating set.\n\n\n\n\n\n","category":"type"},{"location":"graph_rules/#GraphProperties.GraphRules.HavelHakimiRule","page":"Graph Rules","title":"GraphProperties.GraphRules.HavelHakimiRule","text":"HavelHakimiRule\n\nA rule that is applied to a degree sequence iteratively to determine if it is graphical.\n\n\n\n\n\n","category":"type"},{"location":"graph_rules/#GraphProperties.GraphRules.ZeroForcingRule","page":"Graph Rules","title":"GraphProperties.GraphRules.ZeroForcingRule","text":"ZeroForcingRule\n\nA rule to determine if vertices set blue is a zero forcing set of g.\n\n\n\n\n\n","category":"type"},{"location":"graph_rules/#GraphProperties.GraphRules.apply!-Union{Tuple{T}, Tuple{Type{DominationRule}, Set{T}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Graph Rules","title":"GraphProperties.GraphRules.apply!","text":"apply!(::Type{DominationRule}, target_set::Set{T}, g::SimpleGraph{T}) where T <: Integer\n\nApply the domination rule to the target set of vertices in the graph g.\n\nThe domination rule states that if a vertex v is in the target set, then on the next iteration (after applying the rule) all of the neighbors of v will be in the target set. The method modifies the target set in place.\n\nArguments\n\ntarget_set::Set{T}: The set of vertices to which the rule is applied.\ng::SimpleGraph{T}: The graph to which the rule is applied.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.GraphRules\n\njulia> g = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> target_set = Set([1]);\n\njulia> apply!(DominationRule, target_set, g)\n\njulia> target_set\nSet([1, 2])\n\njulia> apply!(DominationRule, target_set, g)\n\njulia> target_set\nSet([1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"graph_rules/#GraphProperties.GraphRules.apply!-Union{Tuple{T}, Tuple{Type{HavelHakimiRule}, Vector{T}, Vector{T}}} where T<:Integer","page":"Graph Rules","title":"GraphProperties.GraphRules.apply!","text":"apply!(::Type{HavelHakimiRule}, sequence::Vector{Int}, eliminations::Vector{Int})\n\nApply the Havel-Hakimi rule to the given sequence.\n\nThe Havel-Hakimi rule is a graphical sequence test that determines if a given sequence is graphical. One step of the rule is to remove the largest number, d1, from the sequence and subtract 1 from the next d1 numbers in the sorted sequence. If the sequence is all zeros, then the original sequence is graphical. If the rule cannot be applied to the sequence, then the sequence is not graphical. This method applies one iteration of the Havel-Hakimi rule to a given sequence in-place and returns true if the rule was applied successfully. Otherwise, a DomainError is thrown. Note: if the sequence is not already sorted in non-increasing order, it will be sorted in-place.\n\nArguments\n\nsequence::Vector{Int}: A sequence of integers.\neliminations::Vector{Int}: A vector to store the eliminations.\n\nReturns\n\ntrue if the rule was applied successfully, otherwise a DomainError is thrown.\n\nExample\n\njulia> using GraphInvariants\n\njulia> D = [3, 3, 2, 2, 1, 1];\n\njulia> eliminations = Int[];\n\njulia> apply!(HavelHakimiRule, D, eliminations)\ntrue\n\njulia> D\n5-element Vector{Int64}:\n 2\n 1\n 1\n 1\n 1\n\njulia> eliminations\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"graph_rules/#GraphProperties.GraphRules.apply!-Union{Tuple{T}, Tuple{Type{ZeroForcingRule}, Set{T}, Graphs.SimpleGraphs.SimpleGraph{T}}} where T<:Integer","page":"Graph Rules","title":"GraphProperties.GraphRules.apply!","text":"apply!(::Type{ZeroForcingRule}, blue::Set{T}, g::SimpleGraph{T}; max_iter=100_000)\n\nIteratively applies the zero forcing rule to g with the set of blue vertices blue.\n\nThe zero forcing rule is a rule that is applied to a graph g with a set of blue vertices blue. The rule is applied iteratively to the graph by checking each vertex in the graph. If a vertex is blue and has exactly one white neighbor, then the white neighbor is turned blue. The rule is applied until no more changes can be made or until max_iter iterations  have been made. \n\nArguments\n\nblue::Set{T}: A set of vertices that are blue.\ng::SimpleGraph{T}: A simple graph.\nmax_iter::Int: The maximum number of iterations to apply the rule.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.GraphRules\n\njulia> g = PathGraph(5);\n\njulia> blue = Set([1, 4]);\n\njulia> apply!(ZeroForcingRule, blue, g)\n\njulia> blue\nSet{Int64} with 5 elements:\n  5\n  4\n  2\n  3\n  1\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#Graph-IO","page":"Graph IO","title":"Graph IO","text":"","category":"section"},{"location":"graph_io/","page":"Graph IO","title":"Graph IO","text":"The GraphIO module includes functionality to load and write edgelist files","category":"page"},{"location":"graph_io/","page":"Graph IO","title":"Graph IO","text":"Modules = [GraphProperties.GraphIO]","category":"page"},{"location":"graph_io/#GraphProperties.GraphIO","page":"Graph IO","title":"GraphProperties.GraphIO","text":"GraphIO\n\nA module for reading and writing graphs from/to various file formats including .csv and .txt.\n\nProvides functionality to:\n\nLoad a graph from an edge list file (load_edgelist)\nWrite a graph to an edge list file (write_edgelist)\n\n\n\n\n\n","category":"module"},{"location":"graph_io/#GraphProperties.GraphIO.CSVFormat","page":"Graph IO","title":"GraphProperties.GraphIO.CSVFormat","text":"CSVFormat\n\nA subtype of EdgeListFormat that represents the .csv file format.\n\n\n\n\n\n","category":"type"},{"location":"graph_io/#GraphProperties.GraphIO.EdgeListFormat","page":"Graph IO","title":"GraphProperties.GraphIO.EdgeListFormat","text":"EdgeListFormat\n\nAn abstract type that represents the file format of an edge list.\n\nSubtypes of EdgeListFormat include:\n\nCSVFormat\nTXTFormat\n\n\n\n\n\n","category":"type"},{"location":"graph_io/#GraphProperties.GraphIO.TXTFormat","page":"Graph IO","title":"GraphProperties.GraphIO.TXTFormat","text":"TXTFormat\n\nA subtype of EdgeListFormat that represents the .txt file format.\n\n\n\n\n\n","category":"type"},{"location":"graph_io/#GraphProperties.GraphIO._determine_format-Tuple{String}","page":"Graph IO","title":"GraphProperties.GraphIO._determine_format","text":"_determine_format(path::String) -> EdgeListFormat\n\nDetermine the file format based on the file extension.\n\nArguments\n\npath::String: The file path.\n\nReturns\n\nAn instance of a subtype of EdgeListFormat indicating the file format.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO._validate_node-Tuple{Any, String}","page":"Graph IO","title":"GraphProperties.GraphIO._validate_node","text":"_va;idate_node(value, column::String)\n\nValidate that a node is a positive integer.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.load_edgelist-Tuple{String, GraphProperties.GraphIO.CSVFormat}","page":"Graph IO","title":"GraphProperties.GraphIO.load_edgelist","text":"load_edgelist(path::String, format::CSVFormat)::SimpleGraph\n\nLoad a graph from a .csv edge list file.\n\nArguments\n\npath::String: The path to the .csv file.\n\nReturns\n\nA SimpleGraph object constructed from the edge list.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.load_edgelist-Tuple{String, GraphProperties.GraphIO.TXTFormat}","page":"Graph IO","title":"GraphProperties.GraphIO.load_edgelist","text":"load_edgelist(path::String, format::TXTFormat)::SimpleGraph\n\nLoad a graph from a .txt edge list file.\n\nArguments\n\npath::String: The path to the .txt file.\n\nReturns\n\nA SimpleGraph object constructed from the edge list.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.load_edgelist-Tuple{String}","page":"Graph IO","title":"GraphProperties.GraphIO.load_edgelist","text":"load_edgelist(path::String)::SimpleGraph\n\nLoad a graph from an edge list file (either .csv or .txt).\n\nArguments\n\npath::String: The path to the edge list file.\n\nReturns\n\nA SimpleGraph object constructed from the edge list.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.write_edgelist!-Tuple{Graphs.SimpleGraphs.SimpleGraph, String, GraphProperties.GraphIO.CSVFormat}","page":"Graph IO","title":"GraphProperties.GraphIO.write_edgelist!","text":"write_edgelist(g::SimpleGraph, path::String, format::CSVFormat)\n\nWrite a graph to a .csv edge list file.\n\nArguments\n\ng::SimpleGraph: The graph object.\npath::String: The path to save the .csv file.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.write_edgelist!-Tuple{Graphs.SimpleGraphs.SimpleGraph, String, GraphProperties.GraphIO.TXTFormat}","page":"Graph IO","title":"GraphProperties.GraphIO.write_edgelist!","text":"write_edgelist!(g::SimpleGraph, path::String, format::TXTFormat)\n\nWrite a graph to a .txt edge list file.\n\nArguments\n\ng::SimpleGraph: The graph object.\npath::String: The path to save the .txt file.\n\n\n\n\n\n","category":"method"},{"location":"graph_io/#GraphProperties.GraphIO.write_edgelist!-Tuple{Graphs.SimpleGraphs.SimpleGraph, String}","page":"Graph IO","title":"GraphProperties.GraphIO.write_edgelist!","text":"write_edgelist(g::SimpleGraph, path::String)\n\nWrite a graph to an edge list file (either .csv or .txt).\n\nArguments\n\ng::SimpleGraph: The graph object.\npath::String: The path to save the edge list file.\n\n\n\n\n\n","category":"method"},{"location":"basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"This module contains basic graph properties functions. ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Modules = [GraphProperties.Basics]","category":"page"},{"location":"basics/#GraphProperties.Basics.diameter-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.diameter","text":"diameter(g::AbstractGraph{T}) where T <: Integer\n\nReturn the diameter of g.\n\nArguments\n\ng::AbstractGraph{T}: A graph.\n\nReturns\n\nThe diameter of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = PathGraph(5);\n\njulia> diameter(g)\n4\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.girth-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.girth","text":"girth(g::SimpleGraph{T}) where T <: Integer\n\nReturn the girth of g.\n\nThe girth of a graph is the length of the shortest cycle in the graph.\n\nArguments\n\ng::SimpleGraph{T}: A graph.\n\nReturns\n\nThe girth of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = PathGraph(5);\n\njulia> girth(g)\nInf\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.is_bull_free-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.is_bull_free","text":"is_bull_free(G::SimpleGraph{T})\n\nReturn true if no induced subgraph of G is a bull, and false otherwise.\n\nA bull is a graph formed by adding two pendant edges to separate verticies of a triangle.\n\nArguments\n\nG::SimpleGraph{T}: A graph.\n\nReturns\n\ntrue if G is bull-free, and false otherwise.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = Graphs.SimpleGraph(5);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> add_edge!(g, 2, 4);\n\njulia> add_edge!(g, 2, 5);\n\njulia> is_bull_free(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.is_claw_free-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.is_claw_free","text":"is_claw_free(G::SimpleGraph{T})\n\nReturn true if no induced subgraph of G is a claw, and false otherwise.\n\nA claw is a graph formed by adding three pendant edges to a single vertex.\n\nArguments\n\nG::SimpleGraph{T}: A graph.\n\nReturns\n\ntrue if G is claw-free, and false otherwise.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = Graphs.SimpleGraph(5);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 1, 4);\n\njulia> add_edge!(g, 1, 5);\n\njulia> is_claw_free(g)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.is_triangle_free-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.is_triangle_free","text":"is_triangle_free(G::SimpleGraph{T})\n\nReturn true if G is triangle-free, and false otherwise.\n\nA graph is triangle-free if it does not contain any induced subgraph isomorphic to a triangle.\n\nArguments\n\nG::SimpleGraph{T}: A graph.\n\nReturns\n\ntrue if G is triangle-free, and false otherwise.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = PathGraph(5);\n\njulia> is_triangle_free(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.order-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.order","text":"order(g::AbstractGraph{T}) where T <: Integer\n\nReturn the order (the number of vertices) of g.\n\nArguments\n\ng::AbstractGraph{T}: A graph.\n\nReturns\n\nThe order of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = PathGraph(5);\n\njulia> order(g)\n5\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.radius-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.radius","text":"radius(g::AbstractGraph{T}) where T <: Integer\n\nReturn the radius of g.\n\nThe radius of a graph is the minimum eccentricity of its vertices. In other words, it is  the minimum distance from any vertex to the farthest vertex from it.\n\nArguments\n\ng::AbstractGraph{T}: A graph.\n\nReturns\n\nThe radius of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = PathGraph(5);\n\njulia> radius(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"basics/#GraphProperties.Basics.size-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T<:Integer","page":"Basics","title":"GraphProperties.Basics.size","text":"size(g::AbstractGraph{T}) where T <: Integer\n\nReturn the size (the number of edges) of g.\n\nArguments\n\ng::AbstractGraph{T}: A graph.\n\nReturns\n\nThe size of g.\n\nExample\n\njulia> using Graphs\n\njulia> using GraphProperties.Basics\n\njulia> g = CompleteGraph(5);\n\njulia> size(g)\n10\n\n\n\n\n\n","category":"method"},{"location":"#Welcome-to-GraphProperties.jl","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"GraphProperties.jl is a versatile Julia package designed for comprehensive analysis and manipulation of graph properties. Seamlessly integrating two key modules - Invariants and Communities - GraphProperties.jl offers powerful tools for computing graph invariants and detecting community structures within networks.","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"The full list of modules is:","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"Basics (e.g. diameter)\nCommunities (e.g. pagerank)\nDegree Sequence Invariants (e.g. annihilation number)\nDraw (e.g. drawing optimal node set)\nGraphIO (e.g. CSV formatting)\nGraph Rules (e.g. Havel-Hakimi Rule)\nInvariants (e.g. Maximum Matching)","category":"page"},{"location":"#Versatility-and-Compatability","page":"Welcome to GraphProperties.jl","title":"Versatility and Compatability","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"GraphProperties.jl's features are tailored to work with the AbstractGraph types from Graphs.jl and SimpleWeightedGraphs.jl. Thus, the package supports both unweighted and weighted graphs, along with a variety of graph input formats. Whether dealing with small-scale or large-scale graph analysis, GraphProperties.jl provides the flexibility and functionality needed for diverse applications.","category":"page"},{"location":"#Performance","page":"Welcome to GraphProperties.jl","title":"Performance","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"Benchmarking in progress","category":"page"},{"location":"#Visualization","page":"Welcome to GraphProperties.jl","title":"Visualization","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"GraphProperties.jl includes tools for graph and community visualization, allowing users to illustrate the structure and properties of graphs intuitively. Visualize graph layouts, community structures, and other key properties to aid in interpretation and communication of results.","category":"page"},{"location":"#Installation","page":"Welcome to GraphProperties.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"To add GraphProperties.jl to your Julia environment, you can use the Julia package manager. In the Julia REPL, enter the package manager by pressing ], then run:","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"(@v1.x) pkg> add https://github.com/RandyRDavila/GraphProperties.jl.git","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"After adding the package, you can start using it in your Julia sessions by importing it:","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"using GraphProperties","category":"page"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"See our other documentation pages for usage examples.","category":"page"},{"location":"#Authors","page":"Welcome to GraphProperties.jl","title":"Authors","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"Randy R. Davila, PhD\nLecturer of Computational Applied Mathematics & Operations Research at Rice University.\nSoftware Engineer at RelationalAI.\nJoshua Yaffee\nRice University: Masters of Industrial Engineering\nData Scientist at Walmart","category":"page"},{"location":"#Further-Information","page":"Welcome to GraphProperties.jl","title":"Further Information","text":"","category":"section"},{"location":"","page":"Welcome to GraphProperties.jl","title":"Welcome to GraphProperties.jl","text":"For more information and updates, you can visit the GitHub repository of GraphProperties.jl.","category":"page"},{"location":"draw/#Draw","page":"Draw","title":"Draw","text":"","category":"section"},{"location":"draw/","page":"Draw","title":"Draw","text":"The Draw module provides resources for visualizing graphs and optimal sets.","category":"page"},{"location":"draw/","page":"Draw","title":"Draw","text":"Modules = [GraphProperties.Draw]","category":"page"},{"location":"draw/#GraphProperties.Draw.draw-Tuple{Graphs.AbstractGraph, AbstractOptimalEdgeSet}","page":"Draw","title":"GraphProperties.Draw.draw","text":"draw(g::AbstractGraph, optset::AbstractOptimalEdgeSet)\n\nDraw a graph with the optimal edge set highlighted.\n\nArguments\n\ng::AbstractGraph: The graph to draw.\noptset::AbstractOptimalEdgeSet: The optimal edge set.\n\nReturns\n\nA plot of the graph with the optimal edge set highlighted.\n\n\n\n\n\n","category":"method"},{"location":"draw/#GraphProperties.Draw.draw-Tuple{Graphs.AbstractGraph, AbstractOptimalNodeSet}","page":"Draw","title":"GraphProperties.Draw.draw","text":"draw(g::AbstractGraph, optset::AbstractOptimalNodeSet)\n\nDraw a graph with the optimal node set highlighted.\n\nArguments\n\ng::AbstractGraph: The graph to draw.\noptset::AbstractOptimalNodeSet: The optimal node set.\n\nReturns\n\nA plot of the graph with the optimal node set highlighted.\n\n\n\n\n\n","category":"method"}]
}
