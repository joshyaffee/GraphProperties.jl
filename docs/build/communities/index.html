<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Communities · GraphProperties.jl</title><meta name="title" content="Communities · GraphProperties.jl"/><meta property="og:title" content="Communities · GraphProperties.jl"/><meta property="twitter:title" content="Communities · GraphProperties.jl"/><meta name="description" content="Documentation for GraphProperties.jl."/><meta property="og:description" content="Documentation for GraphProperties.jl."/><meta property="twitter:description" content="Documentation for GraphProperties.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphProperties.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome to GraphProperties.jl</a></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../invariants/">Invariants</a></li><li class="is-active"><a class="tocitem" href>Communities</a></li><li><a class="tocitem" href="../degree_sequence_invariants/">Degree Sequence Invariants</a></li><li><a class="tocitem" href="../draw/">Draw</a></li><li><a class="tocitem" href="../graph_rules/">Graph Rules</a></li><li><a class="tocitem" href="../graph_io/">Graph IO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Communities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Communities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/joshyaffee/GraphProperties.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/joshyaffee/GraphProperties.jl/blob/main/docs/src/communities.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Communities"><a class="docs-heading-anchor" href="#Communities">Communities</a><a id="Communities-1"></a><a class="docs-heading-anchor-permalink" href="#Communities" title="Permalink"></a></h1><p>This module contains functions for community detection algorithms and related operations. Most code is derived from the <a href="https://github.com/RandyRDavila/GraphCommunities.jl">Graph Communities Julia Package</a>. Algorithms include label propagation, pagerank, k-clique, and others. The module also includes other methods for graph construction, community analysis, and visualization.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.ChainedCliques" href="#GraphProperties.Communities.ChainedCliques"><code>GraphProperties.Communities.ChainedCliques</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChainedCliques &lt;: CommunityGraph</code></pre><p>A graph structure that represents a series of connected cliques.</p><p><strong>Fields</strong></p><ul><li><code>num_cliques::Int</code>: The number of cliques in the graph.</li><li><code>clique_size::Int</code>: The number of nodes in each clique.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">graph_info = ChainedCliques(num_cliques=5, clique_size=4)
graph = generate(graph_info)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L239-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.CommunityDetectionAlgorithm" href="#GraphProperties.Communities.CommunityDetectionAlgorithm"><code>GraphProperties.Communities.CommunityDetectionAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CommunityDetectionAlgorithm</code></pre><p>Abstract type representing a community detection algorithm. This serves as the base type for various community detection algorithms implemented in the package.</p><p><strong>Notes</strong></p><p>All custom community detection algorithms in the package should subtype this abstract type. See <a href="#GraphProperties.Communities.Louvain"><code>Louvain</code></a>, <a href="#GraphProperties.Communities.KClique"><code>KClique</code></a>, etc. for concrete implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.CommunityGraph" href="#GraphProperties.Communities.CommunityGraph"><code>GraphProperties.Communities.CommunityGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CommunityGraph</code></pre><p>An abstract type representing a graph with community structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.FastLPA" href="#GraphProperties.Communities.FastLPA"><code>GraphProperties.Communities.FastLPA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastLPA &lt;: CommunityDetectionAlgorithm</code></pre><p>The (Fast) Label Propagation algorithm for community detection in networks.</p><p>The Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.</p><p>The algorithm can be run in either synchronous or asynchronous mode:</p><ul><li><strong>Synchronous</strong>: All nodes update their labels simultaneously in each iteration.</li><li><strong>Asynchronous</strong>: Nodes update their labels in a random order (not yet implemented).</li></ul><p><strong>Arguments</strong></p><ul><li><code>synchronous::Bool</code>: If <code>true</code>, updates labels in synchronous mode; if <code>false</code> (default),</li></ul><p>updates labels in asynchronous mode.</p><ul><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t</li></ul><p>converge within this number of iterations, it will halt and return the current vector.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(FastLPA(), graph)            # Synchronous (default)</code></pre><p><strong>References</strong></p><ul><li>Raghavan, U. N., Albert, R., &amp; Kumara, S. (2007). Near linear time algorithm to detect</li></ul><p>community structures in large-scale networks. Physical review E, 76(3), 036106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L140-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.KClique" href="#GraphProperties.Communities.KClique"><code>GraphProperties.Communities.KClique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KClique &lt;: CommunityDetectionAlgorithm</code></pre><p>The K-Clique Percolation algorithm for community detection in networks.</p><p>This method identifies communities based on the presence of <code>K</code>-clique (with <code>K = 3</code>) structures within the graph, where a <code>K</code>-clique is a fully connected subgraph of <code>K</code> nodes. Two <code>K</code>-cliques are adjacent if they share <code>K-1</code> nodes, and a community is defined as the union of <code>K</code>-cliques that can be reached from each other through a series of adjacent <code>K</code>-cliques.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(KClique(), graph)</code></pre><p><strong>References</strong></p><ul><li>Palla, G., Derényi, I., Farkas, I., &amp; Vicsek, T. (2005). Uncovering the overlapping community structure of complex networks in nature and society. Nature, 435(7043), 814-818.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L73-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.KarateClub" href="#GraphProperties.Communities.KarateClub"><code>GraphProperties.Communities.KarateClub</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KarateClub &lt;: CommunityGraph</code></pre><p>The <code>KarateClub</code> graph, often referred to as the &quot;Zachary&#39;s Karate Club&quot;, is a social network of friendships between 34 members of a karate club at a US university in the 1970s. This dataset has become a standard benchmark in community detection literature because of its well-documented community structure.</p><p>The graph captures the observed friendships between the 34 members. During the course of the study, the club split into two communities due to a conflict, making it a valuable dataset for studying community detection algorithms.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">graph = generate(KarateClub())</code></pre><p><strong>References</strong></p><ul><li>Zachary, W. W. (1977). An information flow model for conflict and fission in small groups. Journal of anthropological research, 452-473.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L305-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.LabelPropagation" href="#GraphProperties.Communities.LabelPropagation"><code>GraphProperties.Communities.LabelPropagation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LabelPropagation &lt;: CommunityDetectionAlgorithm</code></pre><p>The Label Propagation algorithm for community detection in networks.</p><p>The Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.</p><p>The algorithm can be run in either synchronous or asynchronous mode:</p><ul><li><strong>Synchronous</strong>: All nodes update their labels simultaneously in each iteration.</li><li><strong>Asynchronous</strong>: Nodes update their labels in a random order.</li></ul><p><strong>Arguments</strong></p><ul><li><code>synchronous::Bool</code>: If <code>true</code>, updates labels in synchronous mode; if <code>false</code> (default),</li></ul><p>updates labels in asynchronous mode.</p><ul><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t</li></ul><p>converge within this number of iterations, it will halt and return the current vector.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(LabelPropagation(), graph)            # Asynchronous (default)
communities = compute(LabelPropagation(sync=true), graph)   # Synchronous</code></pre><p><strong>References</strong></p><ul><li>Raghavan, U. N., Albert, R., &amp; Kumara, S. (2007). Near linear time algorithm to detect</li></ul><p>community structures in large-scale networks. Physical review E, 76(3), 036106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L96-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.Louvain" href="#GraphProperties.Communities.Louvain"><code>GraphProperties.Communities.Louvain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Louvain &lt;: CommunityDetectionAlgorithm</code></pre><p>The Louvain algorithm for community detection in networks.</p><p>This method optimizes the modularity of partitions of the graph. It follows a greedy optimization approach that generally operates in time (O(n \log n)) , making it efficient for large-scale networks.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(Louvain(), graph)</code></pre><p><strong>References</strong></p><ul><li>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding</li></ul><p>of communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L48-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.PageRank" href="#GraphProperties.Communities.PageRank"><code>GraphProperties.Communities.PageRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PageRank &lt;: CommunityDetectionAlgorithm</code></pre><p>PageRank is an algorithm originally designed for ranking web pages in search results. However, it can also be used more broadly in networks to determine the importance of nodes within a graph. The underlying principle is that more important nodes are likely to receive more links from other nodes.</p><p>The algorithm computes a stationary distribution of a random walk on the graph where, at each step, with probability <code>d</code>, the walker randomly chooses an outgoing link from its current node and with probability <code>1 - d</code>, it jumps to a random node in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>d::Float64</code>: Damping factor (default is 0.85). It represents the probability that the random walker follows an outgoing edge. Typically set between 0.85 and 0.9.</li><li><code>tol::Float64</code>: Tolerance for determining convergence (default is 1e-6). The algorithm stops iterating once the change between subsequent PageRank vectors is below this value.</li><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t converge within this number of iterations, it will halt and return the current vector.</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">pageranks = compute(PageRank(), graph)  # Using default parameters
pageranks = compute(PageRank(d=0.9, tol=1e-7, max_iter=150), graph)</code></pre><p><strong>References</strong></p><ul><li>Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L183-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.PlantedPartition" href="#GraphProperties.Communities.PlantedPartition"><code>GraphProperties.Communities.PlantedPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlantedPartition &lt;: CommunityGraph</code></pre><p>The <code>PlantedPartition</code> model, also known as the Stochastic Block Model (SBM), is a probabilistic model commonly used for generating synthetic networks with inherent community structures. This model creates a graph by partitioning nodes into distinct communities and then adding edges between nodes based on intra-community and inter-community probabilities.</p><p><strong>Arguments</strong></p><ul><li><code>n_communities::Int</code>: Number of communities or blocks in the graph.</li><li><code>nodes_per_community::Int</code>: Number of nodes within each community.</li><li><code>pintra::Float64</code>: Probability of creating an edge between two nodes within the same community. This defines the density of intra-community edges.</li><li><code>pinter::Float64</code>: Probability of creating an edge between two nodes from different communities. This defines the sparsity of inter-community edges.</li></ul><p>Typically, <code>pintra</code> is set to be much larger than <code>pinter</code> to ensure dense intra-community connections and sparse inter-community connections, thereby creating discernible community structures.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">graph1 = generate(PlantedPartition())  # Using default parameters
graph2 = generate(PlantedPartition(n_communities=5, nodes_per_community=10, pintra=0.8, pinter=0.02))</code></pre><p><strong>References</strong></p><ul><li>Holland, P. W., Laskey, K. B., &amp; Leinhardt, S. (1983). Stochastic blockmodels: First steps. Social networks, 5(2), 109-137.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/Communities.jl#L262-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._adaptive_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}" href="#GraphProperties.Communities._adaptive_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}"><code>GraphProperties.Communities._adaptive_regularization_pagerank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adaptive_pagerank(
    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}</code></pre><p>Helper function for compute(Pagerank, g), computes the PageRank values of the nodes in graph <code>g</code> using the adaptive regularization PageRank algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>P::SparseMatrixCSC</code>: The Markov Chain associated with <code>g</code>.</li><li><code>d::Float64</code>: The initial damping factor. 0 &lt; d &lt; 1.0</li><li><code>tol::Float64</code>: The tolerance for convergence.</li><li><code>max_iter::Int64</code>: The maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Float64</code> where each entry represents the PageRank value of the corresponding node in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/pagerank.jl#L176-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._classical_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}" href="#GraphProperties.Communities._classical_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}"><code>GraphProperties.Communities._classical_pagerank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_classical_pagerank(
    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}</code></pre><p>Helper function for compute(Pagerank, g), computes the PageRank values of the nodes in     graph <code>g</code> using the classical PageRank algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>P::SparseMatrixCSC</code>: The Markov Chain associated with <code>g</code>.</li><li><code>d::Float64</code>: The damping factor.</li><li><code>tol::Float64</code>: The tolerance for convergence.</li><li><code>max_iter::Int64</code>: The maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Float64</code> where each entry represents the PageRank value of the   corresponding node in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/pagerank.jl#L77-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}" href="#GraphProperties.Communities._draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}"><code>GraphProperties.Communities._draw_communities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_communities(g::AbstractGraph, communities::Dict{Int, Int})</code></pre><p>Internal function to draw the graph <code>g</code> with nodes colored based on their community assignments.</p><p>This function maps each unique community label to a distinct color and then generates a plot where each node in the graph <code>g</code> is colored according to its community label.</p><p><strong>Arguments</strong></p><ul><li><code>g::AbstractGraph</code>: The input graph.</li><li><code>communities::Dict{Int, Int}</code>: A dictionary mapping each vertex to its community label.</li></ul><p><strong>Returns</strong></p><ul><li>A plot object with nodes colored based on their community label. Each unique community is represented by a unique color.</li></ul><p><strong>Notes</strong></p><ul><li>This function is an internal helper and is typically not called directly by users. It is used by higher-level community drawing functions which prepare and pass the community mapping in the form of a dictionary.</li><li>The function assumes that every vertex in the graph <code>g</code> is assigned a community label in the <code>communities</code> dictionary. If any vertex is missing a label, an error will be raised in the calling function.</li><li>The colors are chosen to be as distinguishable as possible, but for graphs with a very large number of communities, some colors may be similar.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = generate(KarateClub())

julia&gt; communities = compute(LabelPropagation(), g)

julia&gt; draw_communities(g, communities)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/community-structure/visualizations.jl#L33-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._iterative_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}" href="#GraphProperties.Communities._iterative_regularization_pagerank-Tuple{SparseArrays.SparseMatrixCSC, Float64, Float64, Int64}"><code>GraphProperties.Communities._iterative_regularization_pagerank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_iterative_pagerank(
    P::SparseMatrixCSC, d::Float64, tol::Float64, max_iter::Int64)::Vector{Float64}</code></pre><p>Helper function for compute(Pagerank, g), computes the PageRank values of the nodes in     graph <code>g</code> using the iterative regularization PageRank algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>P::SparseMatrixCSC</code>: The Markov Chain associated with <code>g</code>.</li><li><code>d::Float64</code>: The initial damping factor, from which the regularization factor is computed. 0 &lt; d &lt; .5</li><li><code>tol::Float64</code>: The tolerance for convergence.</li><li><code>max_iter::Int64</code>: The maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Float64</code> where each entry represents the PageRank value of the corresponding node in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/pagerank.jl#L122-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._label_propagation_sweep!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Tuple{Int64, Int64}}}" href="#GraphProperties.Communities._label_propagation_sweep!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Int64}, Vector{Tuple{Int64, Int64}}}"><code>GraphProperties.Communities._label_propagation_sweep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_label_propagation_sweep!(
    pres_labels::Vector{Int},
    next_labels::Vector{Int},
    seen_labels::Vector{Int},
    seen_label_counts::Vector{Int},
    edge_list::Vector{Tuple{Int,Int}}
)::Bool</code></pre><p>Performs a single sweep of label propagation on a graph.</p><p>This function updates the labels of vertices based on the most frequent labels among their neighbors, using a provided edge list.</p><p><strong>Arguments</strong></p><ul><li><code>pres_labels::Vector{Int}</code>: The current labels of the vertices.</li><li><code>next_labels::Vector{Int}</code>: The vector to store the updated labels.</li><li><code>seen_labels::Vector{Int}</code>: A buffer vector to store observed neighbor labels.</li><li><code>seen_label_counts::Vector{Int}</code>: A vector to count occurrences of each label.</li><li><code>edge_list::Vector{Tuple{Int,Int}}</code>: The list of edges in the graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the labeling has reached a stationary state (no changes), <code>false</code> otherwise.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes the edge list is lexicographically ordered.</li><li>Edges are processed sequentially, and labels are updated based on the most frequent neighbor labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-label-propagation.jl#L50-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._max_argmax_in_seen-Tuple{Vector{Int64}, Vector{Int64}, Int64}" href="#GraphProperties.Communities._max_argmax_in_seen-Tuple{Vector{Int64}, Vector{Int64}, Int64}"><code>GraphProperties.Communities._max_argmax_in_seen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_max_argmax_in_seen(
    seen_label_counts::Vector{Int},
    seen_labels::Vector{Int},
    n_seen_labels::Int
)::Int</code></pre><p>Finds the maximum label with the highest count among seen labels.</p><p>This function is used in the label propagation algorithm to determine the most popular label among a node&#39;s neighbors.</p><p><strong>Arguments</strong></p><ul><li><code>seen_label_counts::Vector{Int}</code>: A vector containing counts of each label seen.</li><li><code>seen_labels::Vector{Int}</code>: The labels that have been seen in the current context.</li><li><code>n_seen_labels::Int</code>: The number of seen labels to consider.</li></ul><p><strong>Returns</strong></p><ul><li>The label with the highest count among the seen labels. In case of a tie, the highest label is chosen.</li></ul><p><strong>Notes</strong></p><ul><li>This function is part of the internal mechanics of label propagation and operates on a subset of labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-label-propagation.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities._max_argmax_in_seen_weighted-Tuple{Vector{Float64}, Vector{Int64}, Int64}" href="#GraphProperties.Communities._max_argmax_in_seen_weighted-Tuple{Vector{Float64}, Vector{Int64}, Int64}"><code>GraphProperties.Communities._max_argmax_in_seen_weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_max_argmax_in_seen_weighted(
    seen_label_weights::Vector{Float64},
    seen_labels::Vector{Int},
    n_seen_labels::Int
)::Int</code></pre><p>Finds the maximum label with the highest accumulated weight among seen labels.</p><p>This function is used in the label propagation algorithm for weighted graphs to determine the most &#39;influential&#39; label among a node&#39;s neighbors, based on the weights of the edges connecting to those neighbors.</p><p><strong>Arguments</strong></p><ul><li><code>seen_label_weights::Vector{Float64}</code>: A vector containing the accumulated weights for each label seen.</li><li><code>seen_labels::Vector{Int}</code>: The labels that have been seen in the current context.</li><li><code>n_seen_labels::Int</code>: The number of seen labels to consider.</li></ul><p><strong>Returns</strong></p><ul><li>The label with the highest accumulated weight among the seen labels. In case of a tie, the highest label is chosen.</li></ul><p><strong>Notes</strong></p><ul><li>This function is part of the internal mechanics of label propagation for weighted graphs and operates on a subset of labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-weighted-label-propagation.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Graphs.SimpleGraphs.SimpleGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Graphs.SimpleGraphs.SimpleGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, g::SimpleGraph)</code></pre><p>Execute the Fast Label Propagation algorithm on a graph.</p><p>This function processes a SimpleGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLabelPropagation</code>: The Fast Label Propagation algorithm instance.</li><li><code>g::SimpleGraph</code>: The graph to be processed, represented as a SimpleGraph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The graph <code>g</code> is first converted into an edge list and the number of vertices is determined.</li><li>This function delegates to <code>_sync_label_propagation</code> for the actual label propagation process.</li><li>Currently, only synchronous label propagation is implemented. If <code>algo.synchronous</code> is <code>false</code>, the function will return <code>nothing</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = generate(PlantedPartition())

julia&gt; compute(FastLPA(), g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-label-propagation.jl#L215-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, SimpleWeightedGraphs.SimpleWeightedGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, SimpleWeightedGraphs.SimpleWeightedGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, g::SimpleWeightedGraph)</code></pre><p>Execute the Fast Label Propagation algorithm on a graph.</p><p>This function processes a <code>SimpleWeightedGraph</code> using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLabelPropagation</code>: The Fast Label Propagation algorithm instance.</li><li><code>g::SimpleWeightedGraph</code>: The graph to be processed, represented as a SimpleWeightedGraph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The graph <code>g</code> is first converted into an edge list and the number of vertices is determined.</li><li>This function delegates to <code>_sync_label_propagation</code> for the actual label propagation process.</li><li>Currently, only synchronous label propagation is implemented. If <code>algo.synchronous</code> is <code>false</code>, the function will return <code>nothing</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; compute(FastLPA(), g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-weighted-label-propagation.jl#L147-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Vector{Tuple{Int64, Int64}}, Int64}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.FastLPA, Vector{Tuple{Int64, Int64}}, Int64}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, edge_list::Vector{Tuple{Int,Int}}, num_vertices::Int)</code></pre><p>Execute the Fast Label Propagation algorithm using a precomputed edge list.</p><p>This variant of the <code>compute</code> function allows for direct input of a graph&#39;s edge list and number of vertices. It&#39;s particularly useful when the edge list has been precomputed or when working with a graph representation that doesn&#39;t conform to a SimpleGraph.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLPA</code>: The Fast Label Propagation algorithm instance.</li><li><code>edge_list::Vector{Tuple{Int,Int}}</code>: The edge list of the graph, where each edge is represented as a tuple of vertex indices.</li><li><code>num_vertices::Int</code>: The number of vertices in the graph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The edge list should be lexicographically sorted and represent a valid graph.</li><li>Only synchronous label propagation is currently implemented.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/fast-label-propagation.jl#L255-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.KClique, Graphs.SimpleGraphs.SimpleGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.KClique, Graphs.SimpleGraphs.SimpleGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::KClique, g::SimpleGraph)::Dict{Int, Int}</code></pre><p>Detect communities in a graph <code>g</code> using the K-Clique algorithm.</p><p>The function first finds triangles (or 3-cliques) in the graph. It then constructs a k-clique graph where nodes represent triangles, and edges indicate overlap. The connected components of this k-clique graph give the communities in the original graph.</p><p><strong>Arguments</strong></p><ul><li><code>algo::KClique</code>: Indicates that the K-Clique algorithm should be used for community detection.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping node IDs in the original graph to their respective community IDs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(KarateClub())

julia&gt; compute(KClique(), g)</code></pre><p><strong>Notes</strong></p><p>Currently, the implementation is restricted to 3-cliques (triangles). Future versions might support other clique sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/k-clique.jl#L78-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.LabelPropagation, Graphs.SimpleGraphs.SimpleGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.LabelPropagation, Graphs.SimpleGraphs.SimpleGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::LabelPropagation, g::SimpleGraph)::LabelArray</code></pre><p>Detect communities in a graph <code>g</code> using the Label Propagation algorithm.</p><p>The algorithm works by initially assigning each node a unique label. Then, in each iteration, each node adopts the label that is most frequent among its neighbors. The algorithm terminates when no node changes its label or after reaching a maximum number of iterations.</p><p><strong>Arguments</strong></p><ul><li><code>algo::LabelPropagation</code>: An instance indicating the settings of the Label Propagation algorithm.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>LabelArray</code> where each index corresponds to a vertex and its value indicates its community label.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(KarateClub())

julia&gt; communities = compute(LabelPropagation(), g)</code></pre><p><strong>Notes</strong></p><p>The algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/label-propagation.jl#L103-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.Louvain, Graphs.SimpleGraphs.SimpleGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.Louvain, Graphs.SimpleGraphs.SimpleGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::Louvain, g::SimpleGraph)</code></pre><p>Detect communities in a graph <code>g</code> using the Louvain algorithm, a method based on modularity optimization.</p><p>The algorithm consists of two phases that are repeated iteratively:</p><ol><li>Local Phase: Each node is moved to the community that yields the highest modularity gain.</li><li>Aggregation Phase: A new graph is constructed where nodes represent communities from the previous phase.</li></ol><p>These phases are repeated until the modularity ceases to increase significantly.</p><p><strong>Arguments</strong></p><ul><li><code>algo::Louvain</code>: Indicates that the Louvain algorithm should be used for community detection.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping node IDs in the original graph to their respective community IDs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(PlantedPartition())

julia&gt; compute(Louvain(), g)</code></pre><p><strong>Notes</strong></p><p>The algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/louvain.jl#L36-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.PageRank, Graphs.AbstractGraph}" href="#GraphProperties.Communities.compute-Tuple{GraphProperties.Communities.PageRank, Graphs.AbstractGraph}"><code>GraphProperties.Communities.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute(algo::PageRank, g::AbstractGraph)::Vector{Float64}</code></pre><p>Compute the PageRank values of the nodes in graph <code>g</code> using the specified PageRank algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>algo::PageRank</code>: The PageRank algorithm configuration object. This should contain properties like (initial) damping factor (<code>d</code>), maximum number of iterations (<code>max_iter</code>), tolerance (<code>tol</code>), and the method: &quot;classical&quot;, &quot;iterative&quot;, or &quot;adaptive&quot; (method_name). The two latter methods are described in the paper PageRank: New Regularizations and Simulation Models (2011) by Boris T. Polyak and Anna V. Timonina</p></li><li><p><code>g::AbstractGraph</code>: The graph for which to compute the PageRank. This can be a simple graph, directed or undirected, or a weighted version of these.</p></li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Float64</code> where each entry represents the PageRank value of the corresponding node in the graph.</li></ul><p><strong>Details</strong></p><p>The function uses the power iteration method to find the principal eigenvector of an altered adjacency matrix. The altered matrix is created by &#39;damping&#39; the original matrix, which is done by adding a constant to each entry as well as taking care of sinks. The iterative and adaptive methods increase the damping factor (decreases perturbance of P) as the algorithm progresses, which is shown to improve convergence. The iterative method increases the damping factor over a determined sequence, while the adaptive method maintains the damping factor until a relaxed tolerance is reached, then lowers the tolerance and repeats until the original tolerance is reached.</p><p>```julia julia&gt; g = generate(PlantedPartition())</p><p>julia&gt; algo = PageRank(d=0.85, max<em>iter=100, tol=1e-6, method</em>name=&quot;adaptive&quot;)</p><p>julia&gt; compute(algo, g)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/pagerank.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}" href="#GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Dict{Int64, Int64}}"><code>GraphProperties.Communities.draw_communities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_communities(g::AbstractGraph, communities::Dict)</code></pre><p>Draw the graph <code>g</code> with nodes colored based on their community assignments.</p><p><strong>Arguments</strong></p><ul><li><code>g::AbstractGraph</code>: The input graph.</li><li><code>communities::Dict</code>: A dictionary mapping each vertex to its community.</li></ul><p><strong>Returns</strong></p><ul><li>A plot with nodes colored based on their community.</li></ul><p><strong>Note</strong></p><p>This function will only work if each node in the graph is assigned to a community.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/community-structure/visualizations.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Vector{Tuple{Int64, Int64}}}" href="#GraphProperties.Communities.draw_communities-Tuple{Graphs.AbstractGraph, Vector{Tuple{Int64, Int64}}}"><code>GraphProperties.Communities.draw_communities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_communities(g::AbstractGraph, node_labels::Vector{Tuple{Int, Int}})</code></pre><p>Draw the graph <code>g</code> with nodes colored based on their label assignments.</p><p><strong>Arguments</strong></p><ul><li><code>g::AbstractGraph</code>: The input graph.</li><li><code>node_labels::Vector{Tuple{Int, Int}}</code>: A vector of tuples, each containing a node and its label.</li></ul><p><strong>Returns</strong></p><ul><li>A plot with nodes colored based on their labels.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = generate(KarateClub())

julia&gt; communities = compute(FastLPA(), g)

julia&gt; draw_communities(g, communities)</code></pre><p><strong>Note</strong></p><p>This function will only work if each node in the graph is included in the <code>node_labels</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/community-structure/visualizations.jl#L76-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.find_triangles-Tuple{Graphs.SimpleGraphs.SimpleGraph}" href="#GraphProperties.Communities.find_triangles-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>GraphProperties.Communities.find_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_triangles(g::SimpleGraph)::Set{Set{Int}}</code></pre><p>Find all the triangles in the given graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: The input graph to search for triangles.</li></ul><p><strong>Returns</strong></p><ul><li>A set containing all the triangles in the graph. Each triangle is represented as a set of 3 vertices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/k-clique.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.ChainedCliques}" href="#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.ChainedCliques}"><code>GraphProperties.Communities.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate(structure::ChainedCliques)::SimpleGraph</code></pre><p>Create a graph consisting of <code>structure.r</code> cliques, each of size <code>structure.k</code>, chained together.</p><ul><li><code>structure.r</code> represents the number of cliques.</li><li><code>structure.k</code> represents the size of each clique.</li></ul><p>Returns a <code>SimpleGraph</code> with the chained cliques.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/graph-constructors/graph-constructors.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.KarateClub}" href="#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.KarateClub}"><code>GraphProperties.Communities.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate(structure::KarateClub)::SimpleGraph</code></pre><p>Construct the famous Zachary&#39;s Karate Club graph. This graph represents the friendships between the 34 members of a karate club studied by Wayne W. Zachary in 1977.</p><p>Returns a <code>SimpleGraph</code> representing the Karate Club network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/graph-constructors/graph-constructors.jl#L96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.PlantedPartition}" href="#GraphProperties.Communities.generate-Tuple{GraphProperties.Communities.PlantedPartition}"><code>GraphProperties.Communities.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate(structure::PlantedPartition)::SimpleGraph</code></pre><p>Generate a graph based on the planted partition model.</p><ul><li><code>structure.n_communities</code> is the number of communities.</li><li><code>structure.nodes_per_community</code> denotes the number of nodes per community.</li><li><code>structure.pintra</code> is the probability of an edge within a community.</li><li><code>structure.pinter</code> is the probability of an edge between communities.</li></ul><p>Returns a <code>SimpleGraph</code> constructed based on the planted partition model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/graph-constructors/graph-constructors.jl#L57-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.graph_modularity-Tuple{Graphs.SimpleGraphs.SimpleGraph, Dict{Int64, Int64}}" href="#GraphProperties.Communities.graph_modularity-Tuple{Graphs.SimpleGraphs.SimpleGraph, Dict{Int64, Int64}}"><code>GraphProperties.Communities.graph_modularity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graph_modularity(g::SimpleGraph, node_to_community::Dict{Int, Int})::Number</code></pre><p>Calculate the modularity of a graph <code>g</code> given a particular community assignment given by <code>node_to_community</code>.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: The input graph.</li><li><code>node_to_community::Dict{Int, Int}</code>: A dictionary mapping each vertex to its community.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The modularity value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/louvain.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.k_clique_graph-Tuple{Set{Set{Int64}}}" href="#GraphProperties.Communities.k_clique_graph-Tuple{Set{Set{Int64}}}"><code>GraphProperties.Communities.k_clique_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_clique_graph(triangles::Set{Set{Int}})::SimpleGraph</code></pre><p>Construct a graph where each node represents a triangle from the input set, and edges are added between nodes if their respective triangles share two vertices.</p><p><strong>Arguments</strong></p><ul><li><code>triangles::Set{Set{Int}}</code>: A set of triangles, where each triangle is represented as a set of 3 vertices.</li></ul><p><strong>Returns</strong></p><ul><li>A graph with nodes representing triangles and edges based on shared vertices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/k-clique.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.label_propagation_sweep!-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}, GraphProperties.Communities.LabelPropagation, Vector{Int64}, Vector{Int64}, Vector{Int64}}" href="#GraphProperties.Communities.label_propagation_sweep!-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}, GraphProperties.Communities.LabelPropagation, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>GraphProperties.Communities.label_propagation_sweep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">label_propagation_sweep!(g::SimpleGraph, labels::LabelArray, algo::LabelPropagation,
                         X::VertexList, new_labels::LabelArray, label_counts::Vector{Int})</code></pre><p>Perform a single iteration of the Label Propagation algorithm on the provided graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li><li><code>labels::LabelArray</code>: An array where each index corresponds to a vertex and its value to its community label.</li><li><code>algo::LabelPropagation</code>: An instance indicating the settings of the Label Propagation algorithm.</li><li><code>X::VertexList</code>: A list of vertices to be considered for the propagation in the given iteration.</li><li><code>new_labels::LabelArray</code>: An array to store new labels if the algorithm is running in synchronous mode.</li><li><code>label_counts::LabelArray</code>: An array to store counts of each label during propagation.</li></ul><p><strong>Notes</strong></p><p>The function modifies the given <code>labels</code> array in-place, reflecting the label changes during propagation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/label-propagation.jl#L53-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.labels_to_dict-Tuple{Vector{Set{Int64}}}" href="#GraphProperties.Communities.labels_to_dict-Tuple{Vector{Set{Int64}}}"><code>GraphProperties.Communities.labels_to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">labels_to_dict(labels::Vector{Set{Int}})::Dict{Int, Int}</code></pre><p>Convert a vector of sets to a dictionary mapping each element to its index in the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/k-clique.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.number_of_communities-Tuple{Vector{Int64}}" href="#GraphProperties.Communities.number_of_communities-Tuple{Vector{Int64}}"><code>GraphProperties.Communities.number_of_communities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_communities(communities::Vector{Int64})::Int</code></pre><p>Calculate the number of unique communities in a graph.</p><p>This function takes a vector where each element represents the community assignment of a node in the graph and returns the total count of unique communities identified.</p><p><strong>Arguments</strong></p><ul><li><code>communities::Vector{Int64}</code>: A vector with each element representing the community ID assigned to a node in the graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The number of unique communities found in the graph.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; community_assignments = [1, 2, 1, 3, 2, 3, 3]

julia&gt; number_of_communities(community_assignments)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/community-structure/community_analysis.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.random_argmax-Tuple{AbstractArray}" href="#GraphProperties.Communities.random_argmax-Tuple{AbstractArray}"><code>GraphProperties.Communities.random_argmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_argmax(arr::AbstractArray)::Int</code></pre><p>Find all indices corresponding to the maximum value of the array and randomly return one of them.</p><p><strong>Arguments</strong></p><ul><li><code>arr::AbstractArray</code>: An array of values.</li></ul><p><strong>Returns</strong></p><ul><li>An index corresponding to a randomly selected maximum value of the array.</li></ul><p><strong>Notes</strong></p><p>If multiple maxima exist in the array, one of them is chosen uniformly at random.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/label-propagation.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphProperties.Communities.update_label_counts!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}" href="#GraphProperties.Communities.update_label_counts!-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>GraphProperties.Communities.update_label_counts!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_label_counts!(label_counts::Vector{Int}, labels::LabelArray, neighbors::VertexList)</code></pre><p>Update the count of labels based on the neighbors of a given vertex.</p><p><strong>Arguments</strong></p><ul><li><code>label_counts::LabelArray</code>: An array to store the count of each label.</li><li><code>labels::LabelArray</code>: An array where each index corresponds to a vertex and its value corresponds to its label.</li><li><code>neighbors::VertexList</code>: List of neighboring vertices for the vertex being considered.</li></ul><p><strong>Notes</strong></p><p>This function is used internally by <code>label_propagation_sweep!</code> to update the label counts for the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joshyaffee/GraphProperties.jl/blob/a0480e27d553099cf58726f53428b0bb2842713b/src/Communities/algorithms/label-propagation.jl#L8-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../invariants/">« Invariants</a><a class="docs-footer-nextpage" href="../degree_sequence_invariants/">Degree Sequence Invariants »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 25 March 2024 17:29">Monday 25 March 2024</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
